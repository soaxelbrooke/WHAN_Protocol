{"ts":1352707164306,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"\r\n\r\n#include <address_book.h>\r\n\r\naddress_entry addressBook[MY_ADDRESS_BOOK_LENGTH]\r\n\r\n\r\n// Add a device to the address book (returns non-zero if address book is full)\r\n// Only interests that match this nodes capabilities are stored\r\nuint8 addNodeToAddressBook(uint16 networkAddress, uint32 macHi, uint32 macLow, \r\n    uint8 locale, uint8 numIntersts, uint8 *interests, uint8 numCapabilities,\r\n    uint8 *capabilities)\r\n{\r\n    uint8 result = 0;\r\n    uint8 i = 0;\r\n    \r\n    // Check if address book is full\r\n    if (numFreeAddressEntries() != 0)\r\n    {\r\n        // If address book isn't full, find first free entry\r\n        for (i = 0; i < MY_ADDRESS_BOOK_LENGTH; i++)\r\n        {\r\n            if (addressBook[i].locale == 0) // If locale is zero, entry is free\r\n            {\r\n                addressBook[i].networkAddress = networkAddress;\r\n                addressBook[i].macHi = macHi;\r\n                addressBook[i].macLow = macLow;\r\n                addressBook[i].locale = locale;\r\n                addressBook[i].numInterests = numInterests;\r\n                memcpy(addressBook[i].interests, interests, numInterests);\r\n                addressBook[i].numCapabilities = numCapabilities;\r\n                memcpy(addressBook[i].capabilities, capabilities, \r\n                    numCapabilities);\r\n                \r\n                break;\r\n                \r\n            }\r\n            \r\n        }\r\n        \r\n    } else {\r\n        result = 1;\r\n    }\r\n    \r\n    return result;\r\n    \r\n}\r\n\r\n// Remove a node form the address book, returns non zero if node not found.\r\nuint8 removeNodeFromAddressBook(uint16 networkAddress)\r\n{\r\n    uint8 i = 0;\r\n    uint8 result = 1;\r\n    \r\n    // If address book isn't full, find first free entry\r\n    for (i = 0; i < MY_ADDRESS_BOOK_LENGTH; i++)\r\n    {\r\n        if (addressBook[i].networkAddress == networkAddress) \r\n        {\r\n            addressBook[i].locale = 0;\r\n                \r\n            result = 0;\r\n            \r\n            break;\r\n            \r\n        }\r\n        \r\n    }\r\n    \r\n    return result;\r\n    \r\n}\r\n\r\n// Returns the number of address book entries\r\nuint8 numAddressBookEntries(void)\r\n{\r\n    return (MY_ADDRESS_BOOK_LENGTH - numFreeAddressEntries);\r\n}\r\n\r\n// Returns number of free spaces in address book\r\nuint8 numFreeAddressEntries(void)\r\n{\r\n    uint8 result = 0;\r\n    uint8 i = 0;\r\n    \r\n    for (i = 0; i < MY_ADDRESS_BOOK_LENGTH; i++)\r\n    {\r\n        if (addressBook[i].locale == 0)\r\n        {\r\n            result += 1;\r\n            \r\n        }\r\n        \r\n    }\r\n    \r\n    return result;\r\n    \r\n}\r\n\r\n// Returns nonzero if network address is not in address book\r\nuint8 isInAddressBook(uin16 networkAddress)\r\n{\r\n    uint8 result = 1;\r\n    uint8 i = 0;\r\n    \r\n    for (i = 0; i < MY_ADDRESS_BOOK_LENGTH; i++)\r\n    {\r\n        if (addressBook[i].networkAddress == networkAddress)\r\n        {\r\n            result = 0;\r\n            \r\n            break;\r\n            \r\n        }\r\n        \r\n    }\r\n    \r\n    return result;\r\n    \r\n}\r\n\r\n// Gets the low 32 bits of the MAC associated with the passed in network address\r\nuint32 getMacLow(uint16 networkAddress)\r\n{\r\n    uint32 result = 0;\r\n    uint8 i = 0;\r\n    \r\n    for (i = 0; i < MY_ADDRESS_BOOK_LENGTH; i++)\r\n    {\r\n        if (addressBook[i].networkAddress == networkAddress)\r\n        {\r\n            result = addressBook[i].macLow;\r\n            \r\n            break;\r\n            \r\n        }\r\n        \r\n    }\r\n    \r\n    return result;\r\n    \r\n}\r\n\r\n// Gets the hi 32 bits of the MAC associated with the passed in network address\r\nuint32 getMacHigh(uint16 networkAddress)\r\n{\r\n    uint32 result = 0;\r\n    uint8 i = 0;\r\n    \r\n    for (i = 0; i < MY_ADDRESS_BOOK_LENGTH; i++)\r\n    {\r\n        if (addressBook[i].networkAddress == networkAddress)\r\n        {\r\n            result = addressBook[i].macHigh;\r\n            \r\n            break;\r\n            \r\n        }\r\n        \r\n    }\r\n    \r\n    return result;\r\n    \r\n}\r\n/*\r\n// Returns a count of the number of nodes in the address book with the passed in\r\n// interest\r\nuint8 numNodesWithInterest(uint8 interest)\r\n{\r\n    uint8 result = 0;\r\n    uint8 i = 0, j = 0;\r\n    \r\n    for (i = 0; i < MY_ADDRESS_BOOK_LENGTH; i++)\r\n    {\r\n        for (j = 0; j < addressBook[i].numInterests; j++)\r\n        {\r\n            if (addressBook[i].interests[j] == interest)\r\n            {\r\n                result += 1;\r\n                break;\r\n                \r\n            }\r\n            \r\n        }\r\n        if (addressBook[i].locale == interest)\r\n        {\r\n            result += 1;\r\n            \r\n        }\r\n        \r\n    }\r\n    \r\n    return result;\r\n    \r\n}\r\n\r\n// Returns a count of the number of nodes in the address book with any of the \r\n// passed in interest\r\nuint8 numNodesWithInterests(uint8 numIntersts, uint8 *interests);\r\n\r\n// Returns a count of the number of nodes in the address book in the passed in\r\n// locale\r\nuint8 numNodesInLocale(uint8 locale);\r\n\r\n// Returns a count of the number of nodes in the address book in the passed in \r\n// locales\r\nuint8 numNodesInLocales(uint8 numLocales, uint8 *locales);\r\n\r\n// Returns a count of nodes with given capabilities\r\nuint8 numNodesWithCapability(uint8 capability);\r\n\r\n// Return a count of nodes with any of given capabilities\r\nuint8 numNodesWithCapabilities(uint8 numCapabilities, uint8 *capabilites);\r\n\r\n// Returns a count of nodes in given locales with given interests\r\nuint8 numNodesInLocalesWithInterests(uint8 numLocales, uint8 *locales, \r\n    uint8 numInterests, uint8 *interests);\r\n\r\n// Returns a count of node sin given locales with given capabilities\r\nuint8 numNodesInLocalesWithCapabilities(uint8 numLocales, uint8 *locales, \r\n    uint8 numCapabilities, uint8 *capabilities);\r\n    \r\n// Populates a passed in array with list of nodes in given locale.\r\n// Assumes that nodes have been counted and that proper memory has been \r\n// allocated.\r\nvoid nodesInLocale(uint16 *networkAddresses, uint8 locale);\r\nvoid nodesInLocales(uint16 *networkAddresses, uint8 numLocales, uint8 *locales);\r\n\r\n// Populates a passed in array with list of nodes with given interests.\r\n// Assumes that nodes have been counted and that proper memory has been \r\n// allocated.\r\nvoid nodesWithInterest(uint16 *networkAddresses, uint8 interest);\r\nvoid nodesWithInterests(uint16 *networkAddresses, uint8 numInterests, \r\n    uint8 *interests);\r\n\r\n// Populates a passed in network address array with list of nodes with given \r\n// capability.  Assumes that nodes have been counted and that proper memory has \r\n// been allocated.\r\nvoid nodesWithCapability(uint16 *networkAddresses, uint8 capability);\r\nvoid nodesWithCapabilities(uint16 *networkAddresses, uint8 numCapabilities, \r\n    uint8 *capabilities);\r\n\r\n// Populates passed in network addres array with list of nodes in given locales\r\n// with given interests or capabilities.  Assumes that nodes have been counted \r\n// and that proper memory has been allocated.\r\nvoid nodesInLocalesWithInterests(uint16 *networkAddresses, uint8 numLocales,\r\n    uint8 *locales, uint8 numInterests, uint8 *interests);\r\nvoid nodesInLocalesWithCapabilities(uint16 *networkAddresses, uint8 numLocales,\r\n    uint8 *locales, uint8 numCapabilities, uint8 *capabilities);\r\n    \r\n*/"]],"start1":0,"start2":0,"length1":0,"length2":7157}]],"length":7157}
{"contributors":[],"silentsave":false,"ts":1352707164247,"patch":[[{"diffs":[[1,"\r\n\r\n#include <address_book.h>\r\n\r\naddress_entry addressBook[MY_ADDRESS_BOOK_LENGTH]\r\n\r\n\r\n// Add a device to the address book (returns non-zero if address book is full)\r\n// Only interests that match this nodes capabilities are stored\r\nuint8 addNodeToAddressBook(uint16 networkAddress, uint32 macHi, uint32 macLow, \r\n    uint8 locale, uint8 numIntersts, uint8 *interests, uint8 numCapabilities,\r\n    uint8 *capabilities)\r\n{\r\n    uint8 result = 0;\r\n    uint8 i = 0;\r\n    \r\n    // Check if address book is full\r\n    if (numFreeAddressEntries() != 0)\r\n    {\r\n        // If address book isn't full, find first free entry\r\n        for (i = 0; i < MY_ADDRESS_BOOK_LENGTH; i++)\r\n        {\r\n            if (addressBook[i].locale == 0) // If locale is zero, entry is free\r\n            {\r\n                addressBook[i].networkAddress = networkAddress;\r\n                addressBook[i].macHi = macHi;\r\n                addressBook[i].macLow = macLow;\r\n                addressBook[i].locale = locale;\r\n                addressBook[i].numInterests = numInterests;\r\n                memcpy(addressBook[i].interests, interests, numInterests);\r\n                addressBook[i].numCapabilities = numCapabilities;\r\n                memcpy(addressBook[i].capabilities, capabilities, \r\n                    numCapabilities);\r\n                \r\n                break;\r\n                \r\n            }\r\n            \r\n        }\r\n        \r\n    } else {\r\n        result = 1;\r\n    }\r\n    \r\n    return result;\r\n    \r\n}\r\n\r\n// Remove a node form the address book, returns non zero if node not found.\r\nuint8 removeNodeFromAddressBook(uint16 networkAddress)\r\n{\r\n    uint8 i = 0;\r\n    uint8 result = 1;\r\n    \r\n    // If address book isn't full, find first free entry\r\n    for (i = 0; i < MY_ADDRESS_BOOK_LENGTH; i++)\r\n    {\r\n        if (addressBook[i].networkAddress == networkAddress) \r\n        {\r\n            addressBook[i].locale = 0;\r\n                \r\n            result = 0;\r\n            \r\n            break;\r\n            \r\n        }\r\n        \r\n    }\r\n    \r\n    return result;\r\n    \r\n}\r\n\r\n// Returns the number of address book entries\r\nuint8 numAddressBookEntries(void)\r\n{\r\n    return (MY_ADDRESS_BOOK_LENGTH - numFreeAddressEntries);\r\n}\r\n\r\n// Returns number of free spaces in address book\r\nuint8 numFreeAddressEntries(void)\r\n{\r\n    uint8 result = 0;\r\n    uint8 i = 0;\r\n    \r\n    for (i = 0; i < MY_ADDRESS_BOOK_LENGTH; i++)\r\n    {\r\n        if (addressBook[i].locale == 0)\r\n        {\r\n            result += 1;\r\n            \r\n        }\r\n        \r\n    }\r\n    \r\n    return result;\r\n    \r\n}\r\n\r\n// Returns nonzero if network address is not in address book\r\nuint8 isInAddressBook(uin16 networkAddress)\r\n{\r\n    uint8 result = 1;\r\n    uint8 i = 0;\r\n    \r\n    for (i = 0; i < MY_ADDRESS_BOOK_LENGTH; i++)\r\n    {\r\n        if (addressBook[i].networkAddress == networkAddress)\r\n        {\r\n            result = 0;\r\n            \r\n            break;\r\n            \r\n        }\r\n        \r\n    }\r\n    \r\n    return result;\r\n    \r\n}\r\n\r\n// Gets the low 32 bits of the MAC associated with the passed in network address\r\nuint32 getMacLow(uint16 networkAddress)\r\n{\r\n    uint32 result = 0;\r\n    uint8 i = 0;\r\n    \r\n    for (i = 0; i < MY_ADDRESS_BOOK_LENGTH; i++)\r\n    {\r\n        if (addressBook[i].networkAddress == networkAddress)\r\n        {\r\n            result = addressBook[i].macLow;\r\n            \r\n            break;\r\n            \r\n        }\r\n        \r\n    }\r\n    \r\n    return result;\r\n    \r\n}\r\n\r\n// Gets the hi 32 bits of the MAC associated with the passed in network address\r\nuint32 getMacHigh(uint16 networkAddress)\r\n{\r\n    uint32 result = 0;\r\n    uint8 i = 0;\r\n    \r\n    for (i = 0; i < MY_ADDRESS_BOOK_LENGTH; i++)\r\n    {\r\n        if (addressBook[i].networkAddress == networkAddress)\r\n        {\r\n            result = addressBook[i].macHigh;\r\n            \r\n            break;\r\n            \r\n        }\r\n        \r\n    }\r\n    \r\n    return result;\r\n    \r\n}\r\n/*\r\n// Returns a count of the number of nodes in the address book with the passed in\r\n// interest\r\nuint8 numNodesWithInterest(uint8 interest)\r\n{\r\n    uint8 result = 0;\r\n    uint8 i = 0, j = 0;\r\n    \r\n    for (i = 0; i < MY_ADDRESS_BOOK_LENGTH; i++)\r\n    {\r\n        for (j = 0; j < addressBook[i].numInterests; j++)\r\n        {\r\n            if (addressBook[i].interests[j] == interest)\r\n            {\r\n                result += 1;\r\n                break;\r\n                \r\n            }\r\n            \r\n        }\r\n        if (addressBook[i].locale == interest)\r\n        {\r\n            result += 1;\r\n            \r\n        }\r\n        \r\n    }\r\n    \r\n    return result;\r\n    \r\n}\r\n\r\n// Returns a count of the number of nodes in the address book with any of the \r\n// passed in interest\r\nuint8 numNodesWithInterests(uint8 numIntersts, uint8 *interests);\r\n\r\n// Returns a count of the number of nodes in the address book in the passed in\r\n// locale\r\nuint8 numNodesInLocale(uint8 locale);\r\n\r\n// Returns a count of the number of nodes in the address book in the passed in \r\n// locales\r\nuint8 numNodesInLocales(uint8 numLocales, uint8 *locales);\r\n\r\n// Returns a count of nodes with given capabilities\r\nuint8 numNodesWithCapability(uint8 capability);\r\n\r\n// Return a count of nodes with any of given capabilities\r\nuint8 numNodesWithCapabilities(uint8 numCapabilities, uint8 *capabilites);\r\n\r\n// Returns a count of nodes in given locales with given interests\r\nuint8 numNodesInLocalesWithInterests(uint8 numLocales, uint8 *locales, \r\n    uint8 numInterests, uint8 *interests);\r\n\r\n// Returns a count of node sin given locales with given capabilities\r\nuint8 numNodesInLocalesWithCapabilities(uint8 numLocales, uint8 *locales, \r\n    uint8 numCapabilities, uint8 *capabilities);\r\n    \r\n// Populates a passed in array with list of nodes in given locale.\r\n// Assumes that nodes have been counted and that proper memory has been \r\n// allocated.\r\nvoid nodesInLocale(uint16 *networkAddresses, uint8 locale);\r\nvoid nodesInLocales(uint16 *networkAddresses, uint8 numLocales, uint8 *locales);\r\n\r\n// Populates a passed in array with list of nodes with given interests.\r\n// Assumes that nodes have been counted and that proper memory has been \r\n// allocated.\r\nvoid nodesWithInterest(uint16 *networkAddresses, uint8 interest);\r\nvoid nodesWithInterests(uint16 *networkAddresses, uint8 numInterests, \r\n    uint8 *interests);\r\n\r\n// Populates a passed in network address array with list of nodes with given \r\n// capability.  Assumes that nodes have been counted and that proper memory has \r\n// been allocated.\r\nvoid nodesWithCapability(uint16 *networkAddresses, uint8 capability);\r\nvoid nodesWithCapabilities(uint16 *networkAddresses, uint8 numCapabilities, \r\n    uint8 *capabilities);\r\n\r\n// Populates passed in network addres array with list of nodes in given locales\r\n// with given interests or capabilities.  Assumes that nodes have been counted \r\n// and that proper memory has been allocated.\r\nvoid nodesInLocalesWithInterests(uint16 *networkAddresses, uint8 numLocales,\r\n    uint8 *locales, uint8 numInterests, uint8 *interests);\r\nvoid nodesInLocalesWithCapabilities(uint16 *networkAddresses, uint8 numLocales,\r\n    uint8 *locales, uint8 numCapabilities, uint8 *capabilities);\r\n    \r\n*/"]],"start1":0,"start2":0,"length1":0,"length2":7157}]],"length":7157,"saved":false}
{"contributors":[],"silentsave":true,"ts":1352771206068,"patch":[[{"diffs":[[0,"\r\n\r\n"],[-1,"\r\n"],[0,"// "],[-1,"Add a device to the address book (returns non-zero if address book is full)\r\n// Only interests that match this nodes capabilities are stored\r\nuint8 addNodeToAddressBook(uint16 networkAddress, uint32 macHi, uint32 macLow, \r\n    uint8 locale, uint8 numIntersts, uint8 *interests, uint8 numCapabilities,\r\n    uint8 *capabilities)\r\n{\r\n    uint8 result = 0;\r\n    uint8 i = 0;\r\n    \r\n    // Check if address book is full\r\n    if (numFreeAddressEntries() != 0)\r\n    {\r\n        // If address book isn't full, find first free entry\r\n        for (i = 0; i < MY_ADDRESS_BOOK_LENGTH; i++)\r\n        {\r\n            if (addressBook[i].locale == 0) // If locale is zero, entry is free\r\n            {\r\n                addressBook[i].networkAddress = networkAddress;\r\n                addressBook[i].macHi = macHi;\r\n                addressBook[i].macLow = macLow;\r\n                addressBook[i].locale = locale;\r\n                addressBook[i].numInterests = numInterests;\r\n                memcpy(addressBook[i].interests, interests, numInterests);\r\n                addressBook[i].numCapabilities = numCapabilities;\r\n                memcpy(addressBook[i].capabilities, capabilities, \r\n                    numCapabilities);\r\n                \r\n                break;\r\n                \r\n            }\r\n            \r\n        }\r\n        \r\n    } else {\r\n        result = 1;\r\n    }\r\n    \r\n    return result;\r\n    \r\n}\r\n\r\n// Remove a node form the address book, returns non zero if node not found.\r\nuint8 removeNodeFromAddressBook(uint16 networkAddress)\r\n{\r\n    uint8 i = 0;\r\n    uint8 result = 1;\r\n    \r\n    // If address book isn't full, find first free entry\r\n    for (i = 0; i < MY_ADDRESS_BOOK_LENGTH; i++)\r\n    {\r\n        if (addressBook[i].networkAddress == networkAddress) \r\n        {\r\n            addressBook[i].locale = 0;\r\n                \r\n            result = 0;\r\n            \r\n            break;\r\n            \r\n        }\r\n        \r\n    }\r\n    \r\n    return result;\r\n    \r\n}\r\n\r\n// Returns the number of address book entries\r\nuint8 numAddressBookEntries(void)\r\n{\r\n    return (MY_ADDRESS_BOOK_LENGTH - numFreeAddressEntries);\r\n}\r\n\r\n// Returns number of free spaces in address book\r\nuint8 numFreeAddressEntries(void)\r\n{\r\n    uint8 result = 0;\r\n    uint8 i = 0;\r\n    \r\n    for (i = 0; i < MY_ADDRESS_BOOK_LENGTH; i++)\r\n    {\r\n        if (addressBook[i].locale == 0)\r\n        {\r\n            result += 1;\r\n            \r\n        }\r\n        \r\n    }\r\n    \r\n    return result;\r\n    \r\n}\r\n\r\n// Returns nonzero if network address is not in address book\r\nuint8 isInAddressBook(uin16 networkAddress)\r\n{\r\n    uint8 result = 1;\r\n    uint8 i = 0;\r\n    \r\n    for (i = 0; i < MY_ADDRESS_BOOK_LENGTH; i++)\r\n    {\r\n        if (addressBook[i].networkAddress == networkAddress)\r\n        {\r\n            result = 0;\r\n            \r\n            break;\r\n            \r\n        }\r\n        \r\n    }\r\n    \r\n    return result;\r\n    \r\n}\r\n\r\n// Gets the low 32 bits of the MAC associated with the passed in network address\r\nuint32 getMacLow(uint16 networkAddress)\r\n{\r\n    uint32 result = 0;\r\n    uint8 i = 0;\r\n    \r\n    for (i = 0; i < MY_ADDRESS_BOOK_LENGTH; i++)\r\n    {\r\n        if (addressBook[i].networkAddress == networkAddress)\r\n        {\r\n            result = addressBook[i].macLow;\r\n            \r\n            break;\r\n            \r\n        }\r\n        \r\n    }\r\n    \r\n    return result;\r\n    \r\n}\r\n\r\n// Gets the hi 32 bits of the MAC associated with the passed in network address\r\nuint32 getMacHigh(uint16 networkAddress)\r\n{\r\n    uint32 result = 0;\r\n    uint8 i = 0;\r\n    \r\n    for (i = 0; i < MY_ADDRESS_BOOK_LENGTH; i++)\r\n    {\r\n        if (addressBook[i].networkAddress == networkAddress)\r\n        {\r\n            result = addressBook[i].macHigh;\r\n            \r\n            break;\r\n            \r\n        }\r\n        \r\n    }\r\n    \r\n    return result;\r\n    \r\n}\r\n/*\r\n// Returns a count of the number of nodes in the address book with the passed in\r\n// interest\r\nuint8 numNodesWithInterest(uint8 interest)\r\n{\r\n    uint8 result = 0;\r\n    uint8 i = 0, j = 0;\r\n    \r\n    for (i = 0; i < MY_ADDRESS_BOOK_LENGTH; i++)\r\n    {\r\n        for (j = 0; j < addressBook[i].numInterests; j++)\r\n        {\r\n            if (addressBook[i].interests[j] == interest)\r\n            {\r\n                result += 1;\r\n                break;\r\n                \r\n            }\r\n            \r\n        }\r\n        if (addressBook[i].locale == interest)\r\n        {\r\n            result += 1;\r\n            \r\n        }\r\n        \r\n    }\r\n    \r\n    return result;\r\n    \r\n}\r\n\r\n// Returns a count of the number of nodes in the address book with any of the \r\n// passed in interest\r\nuint8 numNodesWithInterests(uint8 numIntersts, uint8 *interests);\r\n\r\n// Returns a count of the number of nodes in the address book in the passed in\r\n// locale\r\nuint8 numNodesInLocale(uint8 locale);\r\n\r\n// Returns a count of the number of nodes in the address book in the passed in \r\n// locales\r\nuint8 numNodesInLocales(uint8 numLocales, uint8 *locales);\r\n\r\n// Returns a count of nodes with given capabilities\r\nuint8 numNodesWithCapability(uint8 capability);\r\n\r\n// Return a count of nodes with any of given capabilities\r\nuint8 numNodesWithCapabilities(uint8 numCapabilities, uint8 *capabilites);\r\n\r\n// Returns a count of nodes in given locales with given interests\r\nuint8 numNodesInLocalesWithInterests(uint8 numLocales, uint8 *locales, \r\n    uint8 numInterests, uint8 *interests);\r\n\r\n// Returns a count of node sin given locales with given capabilities\r\nuint8 numNodesInLocalesWithCapabilities(uint8 numLocales, uint8 *locales, \r\n    uint8 numCapabilities, uint8 *capabilities);\r\n    \r\n// Populates a passed in array with list of nodes in given locale.\r\n// Assumes that nodes have been counted and that proper memory has been \r\n// allocated.\r\nvoid nodesInLocale(uint16 *networkAddresses, uint8 locale);\r\nvoid nodesInLocales(uint16 *networkAddresses, uint8 numLocales, uint8 *locales);\r\n\r\n// Populates a passed in array with list of nodes with given interests.\r\n// Assumes that nodes have been counted and that proper memory has been \r\n// allocated.\r\nvoid nodesWithInterest(uint16 *networkAddresses, uint8 interest);\r\nvoid nodesWithInterests(uint16 *networkAddresses, uint8 numInterests, \r\n    uint8 *interests);\r\n\r\n// Populates a passed in network address array with list of nodes with given \r\n// capability.  Assumes that nodes have been counted and that proper memory has \r\n// been allocated.\r\nvoid nodesWithCapability(uint16 *networkAddresses, uint8 capability);\r\nvoid nodesWithCapabilities(uint16 *networkAddresses, uint8 numCapabilities, \r\n    uint8 *capabilities);\r\n\r\n// Populates passed in network addres array with list of nodes in given locales\r\n// with given interests or capabilities.  Assumes that nodes have been counted \r\n// and that proper memory has been allocated.\r\nvoid nodesInLocalesWithInterests(uint16 *networkAddresses, uint8 numLocales,\r\n    uint8 *locales, uint8 numInterests, uint8 *interests);\r\nvoid nodesInLocalesWithCapabilities(uint16 *networkAddresses, uint8 numLocales,\r\n    uint8 *locales, uint8 numCapabilities, uint8 *capabilities);\r\n    \r\n*/\r\n\r\n#include <address_book.h>\r\n\r\naddress_entry addressBook[MY_ADDRESS_BOOK_LENGTH]\r\n"],[0,"\r\n\r\n"]],"start1":82,"start2":82,"length1":7163,"length2":11}]],"length":7162,"saved":false}
{"ts":1352771209673,"patch":[[{"diffs":[[0,"]\r\n\r\n// "],[1,"TODO: make"],[0,"\r\n\r\n// A"]],"start1":81,"start2":81,"length1":16,"length2":26}]],"length":7172,"saved":false}
{"ts":1352771217761,"patch":[[{"diffs":[[0,"DO: make"],[1," some mechanism for storing this in non-volatile "],[0,"\r\n\r\n// A"]],"start1":91,"start2":91,"length1":16,"length2":65}]],"length":7221,"saved":false}
{"ts":1352771220113,"patch":[[{"diffs":[[0,"olatile "],[1,"memory!"],[0,"\r\n\r\n// A"]],"start1":140,"start2":140,"length1":16,"length2":23}]],"length":7228,"saved":false}
{"ts":1353093306602,"patch":[[{"diffs":[[0,"include "],[-1,"<"],[1,"\""],[0,"address_"]],"start1":5,"start2":5,"length1":17,"length2":17}]],"length":7228,"saved":false}
{"ts":1353093307933,"patch":[[{"diffs":[[0,"ok.h"],[-1,">"],[1,"\""],[0,"\r\n\r\n"]],"start1":24,"start2":24,"length1":9,"length2":9}]],"length":7228,"saved":false}
{"ts":1353093604662,"patch":[[{"diffs":[[0,"_LENGTH]"],[1,";"],[0,"\r\n\r\n// T"]],"start1":74,"start2":74,"length1":16,"length2":17}]],"length":7229,"saved":false}
{"ts":1353093630859,"patch":[[{"diffs":[[0,"sEntries"],[1,"()"],[0,");\r\n}\r\n\r"]],"start1":2261,"start2":2261,"length1":16,"length2":18}]],"length":7231,"saved":false}
{"ts":1353093647611,"patch":[[{"diffs":[[0,"Book(uin"],[1,"t"],[0,"16 netwo"]],"start1":2708,"start2":2708,"length1":16,"length2":17}]],"length":7232,"saved":false}
{"contributors":[],"silentsave":true,"ts":1353095268598,"patch":[[{"diffs":[[0,"i].macHi"],[-1,"gh"],[0,";\r\n     "]],"start1":3854,"start2":3854,"length1":18,"length2":16}]],"length":7230,"saved":false}
{"ts":1353095313049,"patch":[[{"diffs":[[0,", uint8 numInter"],[1,"e"],[0,"sts, uint8 *inte"]],"start1":402,"start2":402,"length1":32,"length2":33}]],"length":7231,"saved":false}
{"contributors":[],"silentsave":true,"ts":1353098133150,"patch":[[{"diffs":[[0,"  \r\n"],[-1,"*/"]],"start1":7225,"start2":7225,"length1":6,"length2":4}]],"length":7229,"saved":false}
{"ts":1353098136401,"patch":[[{"diffs":[[0,"\n}\r\n"],[-1,"/*"],[0,"\r\n//"]],"start1":3973,"start2":3973,"length1":10,"length2":8}]],"length":7227,"saved":false}
{"ts":1353098151631,"patch":[[{"diffs":[[0,"int8 *interests)"],[-1,";"],[1,"\r\n{\r\n    "],[0,"\r\n\r\n// Returns a"]],"start1":4802,"start2":4802,"length1":33,"length2":41}]],"length":7235,"saved":false}
{"ts":1353098152849,"patch":[[{"diffs":[[0,"ts)\r\n{\r\n"],[-1,"    "],[1,"}"],[0,"\r\n\r\n// R"]],"start1":4815,"start2":4815,"length1":20,"length2":17}]],"length":7232,"saved":false}
{"ts":1353098153653,"patch":[[{"diffs":[[0,"ts)\r\n{\r\n"],[1,"    \r\n"],[0,"}\r\n\r\n// "]],"start1":4815,"start2":4815,"length1":16,"length2":22}]],"length":7238,"saved":false}
{"ts":1353098156584,"patch":[[{"diffs":[[0," locale)"],[-1,";"],[1,"\r\n{\r\n    "],[0,"\r\n\r\n// R"]],"start1":4953,"start2":4953,"length1":17,"length2":25}]],"length":7246,"saved":false}
{"ts":1353098157777,"patch":[[{"diffs":[[0,"{\r\n    \r"],[1,"\n}\r"],[0,"\n\r\n// Re"]],"start1":4963,"start2":4963,"length1":16,"length2":19}]],"length":7249,"saved":false}
{"ts":1353098163091,"patch":[[{"diffs":[[0,"t8 *locales)"],[-1,";"],[1,"\r\n{\r\n    \r\n}"],[0,"\r\n\r\n// Retur"]],"start1":5115,"start2":5115,"length1":25,"length2":36},{"diffs":[[0,"ability)"],[-1,";"],[1,"\r\n"],[0,"\r\n\r\n// R"]],"start1":5234,"start2":5234,"length1":17,"length2":18}]],"length":7261,"saved":false}
{"ts":1353098164695,"patch":[[{"diffs":[[0,"ility)\r\n"],[1,"{\r\n    \r\n}"],[0,"\r\n\r\n// R"]],"start1":5236,"start2":5236,"length1":16,"length2":26}]],"length":7271,"saved":false}
{"ts":1353098167197,"patch":[[{"diffs":[[0,"bilites)"],[-1,";"],[1,"\r\n{\r\n    "],[0,"\r\n\r\n// R"]],"start1":5382,"start2":5382,"length1":17,"length2":25}]],"length":7279,"saved":false}
{"ts":1353098168770,"patch":[[{"diffs":[[0,"{\r\n    \r"],[1,"\n}\r"],[0,"\n\r\n// Re"]],"start1":5392,"start2":5392,"length1":16,"length2":19}]],"length":7282,"saved":false}
{"ts":1353098174059,"patch":[[{"diffs":[[0," *interests)"],[-1,";"],[1,"\r\n{\r\n    \r\n}"],[0,"\r\n\r\n// Retur"]],"start1":5575,"start2":5575,"length1":25,"length2":36},{"diffs":[[0,"8 *capabilities)"],[-1,";"],[0,"\r\n    \r\n// Popul"]],"start1":5780,"start2":5780,"length1":33,"length2":32}]],"length":7292,"saved":false}
{"ts":1353098175379,"patch":[[{"diffs":[[0,"abilities)\r\n"],[1,"{\r\n"],[0,"    \r\n// Pop"]],"start1":5786,"start2":5786,"length1":24,"length2":27}]],"length":7295,"saved":false}
{"ts":1353098176783,"patch":[[{"diffs":[[0,"\r\n    \r\n"],[1,"}\r\n    \r\n"],[0,"// Popul"]],"start1":5799,"start2":5799,"length1":16,"length2":25}]],"length":7304,"saved":false}
{"ts":1353098179862,"patch":[[{"diffs":[[0," locale)"],[-1,";"],[1,"\r\n"],[0,"\r\nvoid n"]],"start1":6023,"start2":6023,"length1":17,"length2":18}]],"length":7305,"saved":false}
{"ts":1353098180308,"patch":[[{"diffs":[[0,"ocale)\r\n"],[1,"{\r\n    "],[0,"\r\nvoid n"]],"start1":6025,"start2":6025,"length1":16,"length2":23}]],"length":7312,"saved":false}
{"ts":1353098181641,"patch":[[{"diffs":[[0,"\r\n    \r\n"],[1,"}\r\n"],[0,"void nod"]],"start1":6034,"start2":6034,"length1":16,"length2":19}]],"length":7315,"saved":false}
{"ts":1353098182801,"patch":[[{"diffs":[[0,"   \r\n}\r\n"],[1,"\r\n"],[0,"void nod"]],"start1":6037,"start2":6037,"length1":16,"length2":18}]],"length":7317,"saved":false}
{"ts":1353098185810,"patch":[[{"diffs":[[0,"locales)"],[-1,";"],[1,"\r\n{\r\n    \r\n}"],[0,"\r\n\r\n// P"]],"start1":6118,"start2":6118,"length1":17,"length2":28}]],"length":7328,"saved":false}
{"ts":1353098189290,"patch":[[{"diffs":[[0,"erests)\r\n{\r\n    "],[1,"ret"],[0,"\r\n}\r\n\r\n// Return"]],"start1":5580,"start2":5580,"length1":32,"length2":35}]],"length":7331,"saved":false}
{"ts":1353098191716,"patch":[[{"diffs":[[0,"\n    ret"],[1,"urn 0;"],[0,"\r\n}\r\n\r\n/"]],"start1":5591,"start2":5591,"length1":16,"length2":22}]],"length":7337,"saved":false}
{"ts":1353098197497,"patch":[[{"diffs":[[0,"es)\r\n{\r\n    "],[1,"return 0;"],[0,"\r\n}\r\n    \r\n/"]],"start1":5802,"start2":5802,"length1":24,"length2":33}]],"length":7346,"saved":false}
{"ts":1353098203474,"patch":[[{"diffs":[[0,"nterest)"],[-1,";"],[1,"\r\n{\r\n    "],[0,"\r\nvoid n"]],"start1":6378,"start2":6378,"length1":17,"length2":25}]],"length":7354,"saved":false}
{"ts":1353098205687,"patch":[[{"diffs":[[0,"st)\r\n{\r\n"],[-1,"    "],[1,"}\r\n"],[0,"\r\nvoid n"]],"start1":6383,"start2":6383,"length1":20,"length2":19}]],"length":7353,"saved":false}
{"ts":1353098207045,"patch":[[{"diffs":[[0,"st)\r\n{\r\n"],[1,"    \r\n"],[0,"}\r\n\r\nvoi"]],"start1":6383,"start2":6383,"length1":16,"length2":22}]],"length":7359,"saved":false}
{"ts":1353098211858,"patch":[[{"diffs":[[0,"terests)"],[-1,";"],[1,"\r\n"],[0,"\r\n\r\n// P"]],"start1":6487,"start2":6487,"length1":17,"length2":18}]],"length":7360,"saved":false}
{"ts":1353098212490,"patch":[[{"diffs":[[0,"rests)\r\n"],[1,"}\r\n"],[0,"\r\n\r\n// P"]],"start1":6489,"start2":6489,"length1":16,"length2":19}]],"length":7363,"saved":false}
{"ts":1353098215174,"patch":[[{"diffs":[[0,"rests)\r\n"],[-1,"}"],[1,"{\r\n    "],[0,"\r\n"],[1,"}"],[0,"\r\n\r\n// P"]],"start1":6489,"start2":6489,"length1":19,"length2":26}]],"length":7370,"saved":false}
{"ts":1353098219584,"patch":[[{"diffs":[[0,"ability)"],[-1,";"],[1,"\r\n{\r\n    \r\n}"],[0,"\r\nvoid n"]],"start1":6752,"start2":6752,"length1":17,"length2":28}]],"length":7381,"saved":false}
{"ts":1353098221219,"patch":[[{"diffs":[[0,"ilities)"],[-1,";"],[1,"\r\n"],[0,"\r\n\r\n// P"]],"start1":6868,"start2":6868,"length1":17,"length2":18}]],"length":7382,"saved":false}
{"ts":1353098223297,"patch":[[{"diffs":[[0,"ities)\r\n"],[1,"{\r\n    \r\n}"],[0,"\r\n\r\n// P"]],"start1":6870,"start2":6870,"length1":16,"length2":26}]],"length":7392,"saved":false}
{"ts":1353098224551,"patch":[[{"diffs":[[0,"   \r\n}\r\n"],[1,"\r\n"],[0,"void nod"]],"start1":6766,"start2":6766,"length1":16,"length2":18}]],"length":7394,"saved":false}
{"ts":1353098228220,"patch":[[{"diffs":[[0,"terests)"],[-1,";"],[1,"\r\n{"],[0,"\r\nvoid n"]],"start1":7230,"start2":7230,"length1":17,"length2":19}]],"length":7396,"saved":false}
{"ts":1353098229237,"patch":[[{"diffs":[[0,"ts)\r\n{\r\n"],[1,"    \r\n    \r\n"],[0,"void nod"]],"start1":7235,"start2":7235,"length1":16,"length2":28}]],"length":7408,"saved":false}
{"ts":1353098230595,"patch":[[{"diffs":[[0,"\r\n    \r\n"],[-1,"    "],[1,"}\r\n"],[0,"\r\nvoid n"]],"start1":7241,"start2":7241,"length1":20,"length2":19}]],"length":7407,"saved":false}
{"ts":1353098233380,"patch":[[{"diffs":[[0,"apabilities)"],[-1,";"],[1,"\r\n"],[0,"\r\n    \r\n"]],"start1":7386,"start2":7386,"length1":21,"length2":22}]],"length":7408,"saved":false}
{"ts":1353098233951,"patch":[[{"diffs":[[0,"ities)\r\n"],[1,"{\r\n    "],[0,"\r\n    \r\n"]],"start1":7392,"start2":7392,"length1":16,"length2":23}]],"length":7415,"saved":false}
{"ts":1353098235287,"patch":[[{"diffs":[[0,")\r\n{\r\n    \r\n"],[1,"}\r\n"],[0,"    \r\n"]],"start1":7397,"start2":7397,"length1":18,"length2":21}]],"length":7418,"saved":false}
{"ts":1353098309343,"patch":[[{"diffs":[[0,"ilites)\r\n{\r\n    "],[1,"return 9"],[0,"\r\n}\r\n\r\n// Return"]],"start1":5383,"start2":5383,"length1":32,"length2":40}]],"length":7426,"saved":false}
{"ts":1353098309833,"patch":[[{"diffs":[[0,"urn "],[-1,"9"],[1,"0"],[0,"\r\n}\r"]],"start1":5402,"start2":5402,"length1":9,"length2":9}]],"length":7426,"saved":false}
{"ts":1353098310757,"patch":[[{"diffs":[[0,"return 0"],[1,";"],[0,"\r\n}\r\n\r\n/"]],"start1":5399,"start2":5399,"length1":16,"length2":17}]],"length":7427,"saved":false}
{"ts":1353098313744,"patch":[[{"diffs":[[0,"bility)\r\n{\r\n    "],[1,"return 0"],[0,"\r\n}\r\n\r\n// Return"]],"start1":5235,"start2":5235,"length1":32,"length2":40}]],"length":7435,"saved":false}
{"ts":1353098315202,"patch":[[{"diffs":[[0,"return 0"],[1,";"],[0,"\r\n}\r\n\r\n/"]],"start1":5251,"start2":5251,"length1":16,"length2":17}]],"length":7436,"saved":false}
{"ts":1353098317777,"patch":[[{"diffs":[[0,"ocales)\r\n{\r\n    "],[1,"return 0;"],[0,"\r\n}\r\n\r\n// Return"]],"start1":5120,"start2":5120,"length1":32,"length2":41}]],"length":7445,"saved":false}
{"ts":1353098321593,"patch":[[{"diffs":[[0,"locale)\r\n{\r\n    "],[1,"return 0;"],[0,"\r\n}\r\n\r\n// Return"]],"start1":4954,"start2":4954,"length1":32,"length2":41}]],"length":7454,"saved":false}
{"ts":1353098324303,"patch":[[{"diffs":[[0,"erests)\r\n{\r\n    "],[1,"return 0;"],[0,"\r\n}\r\n\r\n// Return"]],"start1":4811,"start2":4811,"length1":32,"length2":41}]],"length":7463,"saved":false}
{"contributors":[],"silentsave":false,"ts":1353099517795,"patch":[[{"diffs":[[0,"k.h\"\r\n\r\n"],[1,"static "],[0,"address_"]],"start1":25,"start2":25,"length1":16,"length2":23},{"diffs":[[0,"{\r\n    \r\n}\r\n"],[-1,"    "],[1,"\r\nvoid nodesInAddressBook(uint16 *networkAddresses)\r\n{\r\n    for (i = 0; i < MY_ADDRESS_BOOK_LENGTH; i++)\r\n    {\r\n        networkAddress[i] = addressBook[i].networkAddress;\r\n        \r\n    }\r\n    \r\n}"],[0,"\r\n"]],"start1":7452,"start2":7452,"length1":18,"length2":211}]],"length":7663,"saved":false}
{"ts":1353099831691,"patch":[[{"diffs":[[0,"\r\n{\r\n    \r\n}\r\n\r\n"],[1,"// Returns a list of all nodes in the network\r\n"],[0,"void nodesInAddr"]],"start1":7450,"start2":7450,"length1":32,"length2":79},{"diffs":[[0,"resses)\r\n{\r\n"],[1,"    uint8 i = 0;\r\n    \r\n"],[0,"    for (i ="]],"start1":7555,"start2":7555,"length1":24,"length2":48},{"diffs":[[0,"H; i++)\r\n    {\r\n"],[1,"        if (addressBook[i].locale != 0)\r\n        {\r\n    "],[0,"        networkA"]],"start1":7632,"start2":7632,"length1":32,"length2":88},{"diffs":[[0,"    "],[-1,"\r\n    }\r\n    \r\n}"],[1,"    \r\n        }\r\n        \r\n    }\r\n    \r\n}\r\n\r\n\r\n// Returns the number of interests a node has\r\nuint8 numNodeInterests(uint16 networkAddress)\r\n{\r\n    uint8 i = 0;\r\n    uint8 result = 0;\r\n    \r\n    for (i = 0; i < MY_ADDRESS_BOOK_LENGTH; i++)\r\n    {\r\n        if (addressBook[i].networkAddress == networkAddress)\r\n        {\r\n            result = addressBook[i].numInterests;\r\n            \r\n            break;\r\n            \r\n        }\r\n        \r\n    }\r\n    \r\n    return result;\r\n    \r\n}\r\n\r\n// Writes a list of interests a node has to the passed in pointer\r\nvoid nodeInterests(uint8 *interests, uint16 networkAddress)\r\n{\r\n    \r\n}\r\n"],[0,"\r\n"]],"start1":7768,"start2":7768,"length1":22,"length2":631}]],"length":8399,"saved":false}
{"ts":1353099957059,"patch":[[{"diffs":[[0,"ddress)\r\n{\r\n"],[1,"    uint8 i = 0, j = 0;\r\n    \r\n    for (i = 0; i < MY_ADDRESS_BOOK_LENGTH; i++)\r\n    {\r\n        if (addressBook[i].networkAddress == networkAddress)\r\n        {\r\n            for (j = 0; j < addressBook[i].numInterests; j++)\r\n            {\r\n                interests[j] = addressBook[i].interests[j];\r\n                \r\n            }\r\n            \r\n            break;\r\n            \r\n        }\r\n        \r\n    }\r\n"],[0,"    \r\n}\r\n\r\n"]],"start1":8376,"start2":8376,"length1":23,"length2":432}]],"length":8808,"saved":false}
{"ts":1353101342445,"patch":[[{"diffs":[[0,"kAddress"],[1,"es"],[0,"[i] = ad"]],"start1":7718,"start2":7718,"length1":16,"length2":18}]],"length":8810,"saved":false}
