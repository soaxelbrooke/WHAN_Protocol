{"ts":1352707164306,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"\r\n\r\n#include <address_book.h>\r\n\r\naddress_entry addressBook[MY_ADDRESS_BOOK_LENGTH]\r\n\r\n\r\n// Add a device to the address book (returns non-zero if address book is full)\r\n// Only interests that match this nodes capabilities are stored\r\nuint8 addNodeToAddressBook(uint16 networkAddress, uint32 macHi, uint32 macLow, \r\n    uint8 locale, uint8 numIntersts, uint8 *interests, uint8 numCapabilities,\r\n    uint8 *capabilities)\r\n{\r\n    uint8 result = 0;\r\n    uint8 i = 0;\r\n    \r\n    // Check if address book is full\r\n    if (numFreeAddressEntries() != 0)\r\n    {\r\n        // If address book isn't full, find first free entry\r\n        for (i = 0; i < MY_ADDRESS_BOOK_LENGTH; i++)\r\n        {\r\n            if (addressBook[i].locale == 0) // If locale is zero, entry is free\r\n            {\r\n                addressBook[i].networkAddress = networkAddress;\r\n                addressBook[i].macHi = macHi;\r\n                addressBook[i].macLow = macLow;\r\n                addressBook[i].locale = locale;\r\n                addressBook[i].numInterests = numInterests;\r\n                memcpy(addressBook[i].interests, interests, numInterests);\r\n                addressBook[i].numCapabilities = numCapabilities;\r\n                memcpy(addressBook[i].capabilities, capabilities, \r\n                    numCapabilities);\r\n                \r\n                break;\r\n                \r\n            }\r\n            \r\n        }\r\n        \r\n    } else {\r\n        result = 1;\r\n    }\r\n    \r\n    return result;\r\n    \r\n}\r\n\r\n// Remove a node form the address book, returns non zero if node not found.\r\nuint8 removeNodeFromAddressBook(uint16 networkAddress)\r\n{\r\n    uint8 i = 0;\r\n    uint8 result = 1;\r\n    \r\n    // If address book isn't full, find first free entry\r\n    for (i = 0; i < MY_ADDRESS_BOOK_LENGTH; i++)\r\n    {\r\n        if (addressBook[i].networkAddress == networkAddress) \r\n        {\r\n            addressBook[i].locale = 0;\r\n                \r\n            result = 0;\r\n            \r\n            break;\r\n            \r\n        }\r\n        \r\n    }\r\n    \r\n    return result;\r\n    \r\n}\r\n\r\n// Returns the number of address book entries\r\nuint8 numAddressBookEntries(void)\r\n{\r\n    return (MY_ADDRESS_BOOK_LENGTH - numFreeAddressEntries);\r\n}\r\n\r\n// Returns number of free spaces in address book\r\nuint8 numFreeAddressEntries(void)\r\n{\r\n    uint8 result = 0;\r\n    uint8 i = 0;\r\n    \r\n    for (i = 0; i < MY_ADDRESS_BOOK_LENGTH; i++)\r\n    {\r\n        if (addressBook[i].locale == 0)\r\n        {\r\n            result += 1;\r\n            \r\n        }\r\n        \r\n    }\r\n    \r\n    return result;\r\n    \r\n}\r\n\r\n// Returns nonzero if network address is not in address book\r\nuint8 isInAddressBook(uin16 networkAddress)\r\n{\r\n    uint8 result = 1;\r\n    uint8 i = 0;\r\n    \r\n    for (i = 0; i < MY_ADDRESS_BOOK_LENGTH; i++)\r\n    {\r\n        if (addressBook[i].networkAddress == networkAddress)\r\n        {\r\n            result = 0;\r\n            \r\n            break;\r\n            \r\n        }\r\n        \r\n    }\r\n    \r\n    return result;\r\n    \r\n}\r\n\r\n// Gets the low 32 bits of the MAC associated with the passed in network address\r\nuint32 getMacLow(uint16 networkAddress)\r\n{\r\n    uint32 result = 0;\r\n    uint8 i = 0;\r\n    \r\n    for (i = 0; i < MY_ADDRESS_BOOK_LENGTH; i++)\r\n    {\r\n        if (addressBook[i].networkAddress == networkAddress)\r\n        {\r\n            result = addressBook[i].macLow;\r\n            \r\n            break;\r\n            \r\n        }\r\n        \r\n    }\r\n    \r\n    return result;\r\n    \r\n}\r\n\r\n// Gets the hi 32 bits of the MAC associated with the passed in network address\r\nuint32 getMacHigh(uint16 networkAddress)\r\n{\r\n    uint32 result = 0;\r\n    uint8 i = 0;\r\n    \r\n    for (i = 0; i < MY_ADDRESS_BOOK_LENGTH; i++)\r\n    {\r\n        if (addressBook[i].networkAddress == networkAddress)\r\n        {\r\n            result = addressBook[i].macHigh;\r\n            \r\n            break;\r\n            \r\n        }\r\n        \r\n    }\r\n    \r\n    return result;\r\n    \r\n}\r\n/*\r\n// Returns a count of the number of nodes in the address book with the passed in\r\n// interest\r\nuint8 numNodesWithInterest(uint8 interest)\r\n{\r\n    uint8 result = 0;\r\n    uint8 i = 0, j = 0;\r\n    \r\n    for (i = 0; i < MY_ADDRESS_BOOK_LENGTH; i++)\r\n    {\r\n        for (j = 0; j < addressBook[i].numInterests; j++)\r\n        {\r\n            if (addressBook[i].interests[j] == interest)\r\n            {\r\n                result += 1;\r\n                break;\r\n                \r\n            }\r\n            \r\n        }\r\n        if (addressBook[i].locale == interest)\r\n        {\r\n            result += 1;\r\n            \r\n        }\r\n        \r\n    }\r\n    \r\n    return result;\r\n    \r\n}\r\n\r\n// Returns a count of the number of nodes in the address book with any of the \r\n// passed in interest\r\nuint8 numNodesWithInterests(uint8 numIntersts, uint8 *interests);\r\n\r\n// Returns a count of the number of nodes in the address book in the passed in\r\n// locale\r\nuint8 numNodesInLocale(uint8 locale);\r\n\r\n// Returns a count of the number of nodes in the address book in the passed in \r\n// locales\r\nuint8 numNodesInLocales(uint8 numLocales, uint8 *locales);\r\n\r\n// Returns a count of nodes with given capabilities\r\nuint8 numNodesWithCapability(uint8 capability);\r\n\r\n// Return a count of nodes with any of given capabilities\r\nuint8 numNodesWithCapabilities(uint8 numCapabilities, uint8 *capabilites);\r\n\r\n// Returns a count of nodes in given locales with given interests\r\nuint8 numNodesInLocalesWithInterests(uint8 numLocales, uint8 *locales, \r\n    uint8 numInterests, uint8 *interests);\r\n\r\n// Returns a count of node sin given locales with given capabilities\r\nuint8 numNodesInLocalesWithCapabilities(uint8 numLocales, uint8 *locales, \r\n    uint8 numCapabilities, uint8 *capabilities);\r\n    \r\n// Populates a passed in array with list of nodes in given locale.\r\n// Assumes that nodes have been counted and that proper memory has been \r\n// allocated.\r\nvoid nodesInLocale(uint16 *networkAddresses, uint8 locale);\r\nvoid nodesInLocales(uint16 *networkAddresses, uint8 numLocales, uint8 *locales);\r\n\r\n// Populates a passed in array with list of nodes with given interests.\r\n// Assumes that nodes have been counted and that proper memory has been \r\n// allocated.\r\nvoid nodesWithInterest(uint16 *networkAddresses, uint8 interest);\r\nvoid nodesWithInterests(uint16 *networkAddresses, uint8 numInterests, \r\n    uint8 *interests);\r\n\r\n// Populates a passed in network address array with list of nodes with given \r\n// capability.  Assumes that nodes have been counted and that proper memory has \r\n// been allocated.\r\nvoid nodesWithCapability(uint16 *networkAddresses, uint8 capability);\r\nvoid nodesWithCapabilities(uint16 *networkAddresses, uint8 numCapabilities, \r\n    uint8 *capabilities);\r\n\r\n// Populates passed in network addres array with list of nodes in given locales\r\n// with given interests or capabilities.  Assumes that nodes have been counted \r\n// and that proper memory has been allocated.\r\nvoid nodesInLocalesWithInterests(uint16 *networkAddresses, uint8 numLocales,\r\n    uint8 *locales, uint8 numInterests, uint8 *interests);\r\nvoid nodesInLocalesWithCapabilities(uint16 *networkAddresses, uint8 numLocales,\r\n    uint8 *locales, uint8 numCapabilities, uint8 *capabilities);\r\n    \r\n*/"]],"start1":0,"start2":0,"length1":0,"length2":7157}]],"length":7157}
{"contributors":[],"silentsave":false,"ts":1352707164247,"patch":[[{"diffs":[[1,"\r\n\r\n#include <address_book.h>\r\n\r\naddress_entry addressBook[MY_ADDRESS_BOOK_LENGTH]\r\n\r\n\r\n// Add a device to the address book (returns non-zero if address book is full)\r\n// Only interests that match this nodes capabilities are stored\r\nuint8 addNodeToAddressBook(uint16 networkAddress, uint32 macHi, uint32 macLow, \r\n    uint8 locale, uint8 numIntersts, uint8 *interests, uint8 numCapabilities,\r\n    uint8 *capabilities)\r\n{\r\n    uint8 result = 0;\r\n    uint8 i = 0;\r\n    \r\n    // Check if address book is full\r\n    if (numFreeAddressEntries() != 0)\r\n    {\r\n        // If address book isn't full, find first free entry\r\n        for (i = 0; i < MY_ADDRESS_BOOK_LENGTH; i++)\r\n        {\r\n            if (addressBook[i].locale == 0) // If locale is zero, entry is free\r\n            {\r\n                addressBook[i].networkAddress = networkAddress;\r\n                addressBook[i].macHi = macHi;\r\n                addressBook[i].macLow = macLow;\r\n                addressBook[i].locale = locale;\r\n                addressBook[i].numInterests = numInterests;\r\n                memcpy(addressBook[i].interests, interests, numInterests);\r\n                addressBook[i].numCapabilities = numCapabilities;\r\n                memcpy(addressBook[i].capabilities, capabilities, \r\n                    numCapabilities);\r\n                \r\n                break;\r\n                \r\n            }\r\n            \r\n        }\r\n        \r\n    } else {\r\n        result = 1;\r\n    }\r\n    \r\n    return result;\r\n    \r\n}\r\n\r\n// Remove a node form the address book, returns non zero if node not found.\r\nuint8 removeNodeFromAddressBook(uint16 networkAddress)\r\n{\r\n    uint8 i = 0;\r\n    uint8 result = 1;\r\n    \r\n    // If address book isn't full, find first free entry\r\n    for (i = 0; i < MY_ADDRESS_BOOK_LENGTH; i++)\r\n    {\r\n        if (addressBook[i].networkAddress == networkAddress) \r\n        {\r\n            addressBook[i].locale = 0;\r\n                \r\n            result = 0;\r\n            \r\n            break;\r\n            \r\n        }\r\n        \r\n    }\r\n    \r\n    return result;\r\n    \r\n}\r\n\r\n// Returns the number of address book entries\r\nuint8 numAddressBookEntries(void)\r\n{\r\n    return (MY_ADDRESS_BOOK_LENGTH - numFreeAddressEntries);\r\n}\r\n\r\n// Returns number of free spaces in address book\r\nuint8 numFreeAddressEntries(void)\r\n{\r\n    uint8 result = 0;\r\n    uint8 i = 0;\r\n    \r\n    for (i = 0; i < MY_ADDRESS_BOOK_LENGTH; i++)\r\n    {\r\n        if (addressBook[i].locale == 0)\r\n        {\r\n            result += 1;\r\n            \r\n        }\r\n        \r\n    }\r\n    \r\n    return result;\r\n    \r\n}\r\n\r\n// Returns nonzero if network address is not in address book\r\nuint8 isInAddressBook(uin16 networkAddress)\r\n{\r\n    uint8 result = 1;\r\n    uint8 i = 0;\r\n    \r\n    for (i = 0; i < MY_ADDRESS_BOOK_LENGTH; i++)\r\n    {\r\n        if (addressBook[i].networkAddress == networkAddress)\r\n        {\r\n            result = 0;\r\n            \r\n            break;\r\n            \r\n        }\r\n        \r\n    }\r\n    \r\n    return result;\r\n    \r\n}\r\n\r\n// Gets the low 32 bits of the MAC associated with the passed in network address\r\nuint32 getMacLow(uint16 networkAddress)\r\n{\r\n    uint32 result = 0;\r\n    uint8 i = 0;\r\n    \r\n    for (i = 0; i < MY_ADDRESS_BOOK_LENGTH; i++)\r\n    {\r\n        if (addressBook[i].networkAddress == networkAddress)\r\n        {\r\n            result = addressBook[i].macLow;\r\n            \r\n            break;\r\n            \r\n        }\r\n        \r\n    }\r\n    \r\n    return result;\r\n    \r\n}\r\n\r\n// Gets the hi 32 bits of the MAC associated with the passed in network address\r\nuint32 getMacHigh(uint16 networkAddress)\r\n{\r\n    uint32 result = 0;\r\n    uint8 i = 0;\r\n    \r\n    for (i = 0; i < MY_ADDRESS_BOOK_LENGTH; i++)\r\n    {\r\n        if (addressBook[i].networkAddress == networkAddress)\r\n        {\r\n            result = addressBook[i].macHigh;\r\n            \r\n            break;\r\n            \r\n        }\r\n        \r\n    }\r\n    \r\n    return result;\r\n    \r\n}\r\n/*\r\n// Returns a count of the number of nodes in the address book with the passed in\r\n// interest\r\nuint8 numNodesWithInterest(uint8 interest)\r\n{\r\n    uint8 result = 0;\r\n    uint8 i = 0, j = 0;\r\n    \r\n    for (i = 0; i < MY_ADDRESS_BOOK_LENGTH; i++)\r\n    {\r\n        for (j = 0; j < addressBook[i].numInterests; j++)\r\n        {\r\n            if (addressBook[i].interests[j] == interest)\r\n            {\r\n                result += 1;\r\n                break;\r\n                \r\n            }\r\n            \r\n        }\r\n        if (addressBook[i].locale == interest)\r\n        {\r\n            result += 1;\r\n            \r\n        }\r\n        \r\n    }\r\n    \r\n    return result;\r\n    \r\n}\r\n\r\n// Returns a count of the number of nodes in the address book with any of the \r\n// passed in interest\r\nuint8 numNodesWithInterests(uint8 numIntersts, uint8 *interests);\r\n\r\n// Returns a count of the number of nodes in the address book in the passed in\r\n// locale\r\nuint8 numNodesInLocale(uint8 locale);\r\n\r\n// Returns a count of the number of nodes in the address book in the passed in \r\n// locales\r\nuint8 numNodesInLocales(uint8 numLocales, uint8 *locales);\r\n\r\n// Returns a count of nodes with given capabilities\r\nuint8 numNodesWithCapability(uint8 capability);\r\n\r\n// Return a count of nodes with any of given capabilities\r\nuint8 numNodesWithCapabilities(uint8 numCapabilities, uint8 *capabilites);\r\n\r\n// Returns a count of nodes in given locales with given interests\r\nuint8 numNodesInLocalesWithInterests(uint8 numLocales, uint8 *locales, \r\n    uint8 numInterests, uint8 *interests);\r\n\r\n// Returns a count of node sin given locales with given capabilities\r\nuint8 numNodesInLocalesWithCapabilities(uint8 numLocales, uint8 *locales, \r\n    uint8 numCapabilities, uint8 *capabilities);\r\n    \r\n// Populates a passed in array with list of nodes in given locale.\r\n// Assumes that nodes have been counted and that proper memory has been \r\n// allocated.\r\nvoid nodesInLocale(uint16 *networkAddresses, uint8 locale);\r\nvoid nodesInLocales(uint16 *networkAddresses, uint8 numLocales, uint8 *locales);\r\n\r\n// Populates a passed in array with list of nodes with given interests.\r\n// Assumes that nodes have been counted and that proper memory has been \r\n// allocated.\r\nvoid nodesWithInterest(uint16 *networkAddresses, uint8 interest);\r\nvoid nodesWithInterests(uint16 *networkAddresses, uint8 numInterests, \r\n    uint8 *interests);\r\n\r\n// Populates a passed in network address array with list of nodes with given \r\n// capability.  Assumes that nodes have been counted and that proper memory has \r\n// been allocated.\r\nvoid nodesWithCapability(uint16 *networkAddresses, uint8 capability);\r\nvoid nodesWithCapabilities(uint16 *networkAddresses, uint8 numCapabilities, \r\n    uint8 *capabilities);\r\n\r\n// Populates passed in network addres array with list of nodes in given locales\r\n// with given interests or capabilities.  Assumes that nodes have been counted \r\n// and that proper memory has been allocated.\r\nvoid nodesInLocalesWithInterests(uint16 *networkAddresses, uint8 numLocales,\r\n    uint8 *locales, uint8 numInterests, uint8 *interests);\r\nvoid nodesInLocalesWithCapabilities(uint16 *networkAddresses, uint8 numLocales,\r\n    uint8 *locales, uint8 numCapabilities, uint8 *capabilities);\r\n    \r\n*/"]],"start1":0,"start2":0,"length1":0,"length2":7157}]],"length":7157,"saved":false}
{"contributors":[],"silentsave":true,"ts":1352771206068,"patch":[[{"diffs":[[0,"\r\n\r\n"],[-1,"\r\n"],[0,"// "],[-1,"Add a device to the address book (returns non-zero if address book is full)\r\n// Only interests that match this nodes capabilities are stored\r\nuint8 addNodeToAddressBook(uint16 networkAddress, uint32 macHi, uint32 macLow, \r\n    uint8 locale, uint8 numIntersts, uint8 *interests, uint8 numCapabilities,\r\n    uint8 *capabilities)\r\n{\r\n    uint8 result = 0;\r\n    uint8 i = 0;\r\n    \r\n    // Check if address book is full\r\n    if (numFreeAddressEntries() != 0)\r\n    {\r\n        // If address book isn't full, find first free entry\r\n        for (i = 0; i < MY_ADDRESS_BOOK_LENGTH; i++)\r\n        {\r\n            if (addressBook[i].locale == 0) // If locale is zero, entry is free\r\n            {\r\n                addressBook[i].networkAddress = networkAddress;\r\n                addressBook[i].macHi = macHi;\r\n                addressBook[i].macLow = macLow;\r\n                addressBook[i].locale = locale;\r\n                addressBook[i].numInterests = numInterests;\r\n                memcpy(addressBook[i].interests, interests, numInterests);\r\n                addressBook[i].numCapabilities = numCapabilities;\r\n                memcpy(addressBook[i].capabilities, capabilities, \r\n                    numCapabilities);\r\n                \r\n                break;\r\n                \r\n            }\r\n            \r\n        }\r\n        \r\n    } else {\r\n        result = 1;\r\n    }\r\n    \r\n    return result;\r\n    \r\n}\r\n\r\n// Remove a node form the address book, returns non zero if node not found.\r\nuint8 removeNodeFromAddressBook(uint16 networkAddress)\r\n{\r\n    uint8 i = 0;\r\n    uint8 result = 1;\r\n    \r\n    // If address book isn't full, find first free entry\r\n    for (i = 0; i < MY_ADDRESS_BOOK_LENGTH; i++)\r\n    {\r\n        if (addressBook[i].networkAddress == networkAddress) \r\n        {\r\n            addressBook[i].locale = 0;\r\n                \r\n            result = 0;\r\n            \r\n            break;\r\n            \r\n        }\r\n        \r\n    }\r\n    \r\n    return result;\r\n    \r\n}\r\n\r\n// Returns the number of address book entries\r\nuint8 numAddressBookEntries(void)\r\n{\r\n    return (MY_ADDRESS_BOOK_LENGTH - numFreeAddressEntries);\r\n}\r\n\r\n// Returns number of free spaces in address book\r\nuint8 numFreeAddressEntries(void)\r\n{\r\n    uint8 result = 0;\r\n    uint8 i = 0;\r\n    \r\n    for (i = 0; i < MY_ADDRESS_BOOK_LENGTH; i++)\r\n    {\r\n        if (addressBook[i].locale == 0)\r\n        {\r\n            result += 1;\r\n            \r\n        }\r\n        \r\n    }\r\n    \r\n    return result;\r\n    \r\n}\r\n\r\n// Returns nonzero if network address is not in address book\r\nuint8 isInAddressBook(uin16 networkAddress)\r\n{\r\n    uint8 result = 1;\r\n    uint8 i = 0;\r\n    \r\n    for (i = 0; i < MY_ADDRESS_BOOK_LENGTH; i++)\r\n    {\r\n        if (addressBook[i].networkAddress == networkAddress)\r\n        {\r\n            result = 0;\r\n            \r\n            break;\r\n            \r\n        }\r\n        \r\n    }\r\n    \r\n    return result;\r\n    \r\n}\r\n\r\n// Gets the low 32 bits of the MAC associated with the passed in network address\r\nuint32 getMacLow(uint16 networkAddress)\r\n{\r\n    uint32 result = 0;\r\n    uint8 i = 0;\r\n    \r\n    for (i = 0; i < MY_ADDRESS_BOOK_LENGTH; i++)\r\n    {\r\n        if (addressBook[i].networkAddress == networkAddress)\r\n        {\r\n            result = addressBook[i].macLow;\r\n            \r\n            break;\r\n            \r\n        }\r\n        \r\n    }\r\n    \r\n    return result;\r\n    \r\n}\r\n\r\n// Gets the hi 32 bits of the MAC associated with the passed in network address\r\nuint32 getMacHigh(uint16 networkAddress)\r\n{\r\n    uint32 result = 0;\r\n    uint8 i = 0;\r\n    \r\n    for (i = 0; i < MY_ADDRESS_BOOK_LENGTH; i++)\r\n    {\r\n        if (addressBook[i].networkAddress == networkAddress)\r\n        {\r\n            result = addressBook[i].macHigh;\r\n            \r\n            break;\r\n            \r\n        }\r\n        \r\n    }\r\n    \r\n    return result;\r\n    \r\n}\r\n/*\r\n// Returns a count of the number of nodes in the address book with the passed in\r\n// interest\r\nuint8 numNodesWithInterest(uint8 interest)\r\n{\r\n    uint8 result = 0;\r\n    uint8 i = 0, j = 0;\r\n    \r\n    for (i = 0; i < MY_ADDRESS_BOOK_LENGTH; i++)\r\n    {\r\n        for (j = 0; j < addressBook[i].numInterests; j++)\r\n        {\r\n            if (addressBook[i].interests[j] == interest)\r\n            {\r\n                result += 1;\r\n                break;\r\n                \r\n            }\r\n            \r\n        }\r\n        if (addressBook[i].locale == interest)\r\n        {\r\n            result += 1;\r\n            \r\n        }\r\n        \r\n    }\r\n    \r\n    return result;\r\n    \r\n}\r\n\r\n// Returns a count of the number of nodes in the address book with any of the \r\n// passed in interest\r\nuint8 numNodesWithInterests(uint8 numIntersts, uint8 *interests);\r\n\r\n// Returns a count of the number of nodes in the address book in the passed in\r\n// locale\r\nuint8 numNodesInLocale(uint8 locale);\r\n\r\n// Returns a count of the number of nodes in the address book in the passed in \r\n// locales\r\nuint8 numNodesInLocales(uint8 numLocales, uint8 *locales);\r\n\r\n// Returns a count of nodes with given capabilities\r\nuint8 numNodesWithCapability(uint8 capability);\r\n\r\n// Return a count of nodes with any of given capabilities\r\nuint8 numNodesWithCapabilities(uint8 numCapabilities, uint8 *capabilites);\r\n\r\n// Returns a count of nodes in given locales with given interests\r\nuint8 numNodesInLocalesWithInterests(uint8 numLocales, uint8 *locales, \r\n    uint8 numInterests, uint8 *interests);\r\n\r\n// Returns a count of node sin given locales with given capabilities\r\nuint8 numNodesInLocalesWithCapabilities(uint8 numLocales, uint8 *locales, \r\n    uint8 numCapabilities, uint8 *capabilities);\r\n    \r\n// Populates a passed in array with list of nodes in given locale.\r\n// Assumes that nodes have been counted and that proper memory has been \r\n// allocated.\r\nvoid nodesInLocale(uint16 *networkAddresses, uint8 locale);\r\nvoid nodesInLocales(uint16 *networkAddresses, uint8 numLocales, uint8 *locales);\r\n\r\n// Populates a passed in array with list of nodes with given interests.\r\n// Assumes that nodes have been counted and that proper memory has been \r\n// allocated.\r\nvoid nodesWithInterest(uint16 *networkAddresses, uint8 interest);\r\nvoid nodesWithInterests(uint16 *networkAddresses, uint8 numInterests, \r\n    uint8 *interests);\r\n\r\n// Populates a passed in network address array with list of nodes with given \r\n// capability.  Assumes that nodes have been counted and that proper memory has \r\n// been allocated.\r\nvoid nodesWithCapability(uint16 *networkAddresses, uint8 capability);\r\nvoid nodesWithCapabilities(uint16 *networkAddresses, uint8 numCapabilities, \r\n    uint8 *capabilities);\r\n\r\n// Populates passed in network addres array with list of nodes in given locales\r\n// with given interests or capabilities.  Assumes that nodes have been counted \r\n// and that proper memory has been allocated.\r\nvoid nodesInLocalesWithInterests(uint16 *networkAddresses, uint8 numLocales,\r\n    uint8 *locales, uint8 numInterests, uint8 *interests);\r\nvoid nodesInLocalesWithCapabilities(uint16 *networkAddresses, uint8 numLocales,\r\n    uint8 *locales, uint8 numCapabilities, uint8 *capabilities);\r\n    \r\n*/\r\n\r\n#include <address_book.h>\r\n\r\naddress_entry addressBook[MY_ADDRESS_BOOK_LENGTH]\r\n"],[0,"\r\n\r\n"]],"start1":82,"start2":82,"length1":7163,"length2":11}]],"length":7162,"saved":false}
{"ts":1352771209673,"patch":[[{"diffs":[[0,"]\r\n\r\n// "],[1,"TODO: make"],[0,"\r\n\r\n// A"]],"start1":81,"start2":81,"length1":16,"length2":26}]],"length":7172,"saved":false}
{"ts":1352771217761,"patch":[[{"diffs":[[0,"DO: make"],[1," some mechanism for storing this in non-volatile "],[0,"\r\n\r\n// A"]],"start1":91,"start2":91,"length1":16,"length2":65}]],"length":7221,"saved":false}
{"ts":1352771220113,"patch":[[{"diffs":[[0,"olatile "],[1,"memory!"],[0,"\r\n\r\n// A"]],"start1":140,"start2":140,"length1":16,"length2":23}]],"length":7228,"saved":false}
{"ts":1353093306602,"patch":[[{"diffs":[[0,"include "],[-1,"<"],[1,"\""],[0,"address_"]],"start1":5,"start2":5,"length1":17,"length2":17}]],"length":7228,"saved":false}
{"ts":1353093307933,"patch":[[{"diffs":[[0,"ok.h"],[-1,">"],[1,"\""],[0,"\r\n\r\n"]],"start1":24,"start2":24,"length1":9,"length2":9}]],"length":7228,"saved":false}
{"ts":1353093604662,"patch":[[{"diffs":[[0,"_LENGTH]"],[1,";"],[0,"\r\n\r\n// T"]],"start1":74,"start2":74,"length1":16,"length2":17}]],"length":7229,"saved":false}
{"ts":1353093630859,"patch":[[{"diffs":[[0,"sEntries"],[1,"()"],[0,");\r\n}\r\n\r"]],"start1":2261,"start2":2261,"length1":16,"length2":18}]],"length":7231,"saved":false}
{"ts":1353093647611,"patch":[[{"diffs":[[0,"Book(uin"],[1,"t"],[0,"16 netwo"]],"start1":2708,"start2":2708,"length1":16,"length2":17}]],"length":7232,"saved":false}
