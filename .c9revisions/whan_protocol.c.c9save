{"ts":1352707256401,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"\r\n\r\n#include <whan_protocol.h>\r\n\r\n// This function is for interfacing with the UART interface\r\nvoid sendMessage(uint32 macHi, uint32 macLow, uint16 networkAddress, \r\n    uint8 rfDataLength, uint8 rfData[])\r\n{\r\n    \r\n    // TODO: fill in this function to tie it to the system UART\r\n    // It should implement the Zigbee Send Request command\r\n    \r\n}\r\n\r\n// Get message from the receive buffer and put it into the passed in variables\r\nvoid getMessage(uint32 *macHi, uint32 *macLow, uint16 *networkAddress,\r\n    uint8 *rfData)\r\n{\r\n    \r\n    // TODO: fill in this function to tie it to the system UART\r\n    // It should implement the Zigbee Receive Packet command\r\n    \r\n}\r\n\r\n// Get message length (the length of rfData)\r\nuint8 getMessageLength(void)\r\n{\r\n    \r\n    // TODO: fill in this function to allow host processor to allocate\r\n    // proper amount of memory for getMessage command.\r\n    \r\n}\r\n\r\n// This function is called by the top level functions, and integrates with the\r\n// lower level sendMessage() function\r\nvoid sendFormattedMessage(uint16 networkAddress, message myMessage)\r\n{\r\n    uint8 i = 0;\r\n    uint32 macLow = getMacLow(networkAddress);\r\n    uint32 macHigh = getMacHigh(networkAddress);\r\n    uint8 rfDataLength = myMessage.messageLength + 7;\r\n    uint8 messageBuffer[rfDataLength];\r\n    \r\n    messageBuffer[0] = myMessage.sourceLocale;\r\n    messageBuffer[1] = (uint8)(myMessage.sourceDeviceType);\r\n    messageBuffer[2] = (uint8)(myMessage.sourceDeviceType >> 8);\r\n    messageBuffer[3] = myMessage.messageCount;\r\n    messageBuffer[4] = myMessage.messageIndex;\r\n    messageBuffer[5] = myMessage.messageType;\r\n    messageBuffer[6] = myMessage.messageLength;\r\n    \r\n    for (i = 0; i < messageLength; i++) \r\n    {\r\n        messageBuffer[i+7] = myMessage.messageData[i];\r\n        \r\n    }\r\n    \r\n    sendMessage(macHigh, macLow, networkAddress, rfDataLength, messageBuffer);\r\n    \r\n}\r\n\r\n// Gets the message type, allowing for branching based on what was received\r\nuint8 getMessageType(uint8 *messageData)\r\n{\r\n    return messageData[5];\r\n    \r\n}\r\n\r\n// User Commands\r\nvoid sendUserCommandChangeValue(uint16 networkAddr, uint8 targetValueType, \r\n    uint32 targetValueData)\r\n{\r\n    message myMessage;\r\n    uint8 buffer[6];\r\n    \r\n    // Populate message fields\r\n    myMessage.sourceLocale = myLocale();\r\n    myMessage.deviceType = MY_DEVICE_TYPE;\r\n    myMessage.messageCount = 0;\r\n    myMessage.messageIndex = 0;\r\n    myMessage.messageType = MESSAGE_TYPE_USER_COMMAND;\r\n    myMessage.messageLength = 6;\r\n    myMessage.messageData = buffer;\r\n    \r\n    // Populate data buffer\r\n    buffer[0] = USER_COMMAND_CHANGE_VALUE;\r\n    buffer[1] = targetValueType;\r\n    buffer[2] = (uint8) ()targetValueData >> 24); // Big endian transmission\r\n    buffer[3] = (uint8) ()targetValueData >> 16);\r\n    buffer[4] = (uint8) ()targetValueData >> 8);\r\n    buffer[5] = (uint8) ()targetValueData >> 0);\r\n    \r\n    sendFormattedMessage(targetAddr, myMessage);\r\n    \r\n}\r\n    \r\nvoid sendUserCommandPromptAbilities(uint16 networkAddress)\r\n{\r\n    message myMessage;\r\n    uint8 buffer[1];\r\n    \r\n    // Populate message fields\r\n    myMessage.sourceLocale = myLocale();\r\n    myMessage.deviceType = MY_DEVICE_TYPE;\r\n    myMessage.messageCount = 0;\r\n    myMessage.messageIndex = 0;\r\n    myMessage.messageType = MESSAGE_TYPE_USER_COMMAND;\r\n    myMessage.messageLength = 1;\r\n    myMessage.messageData = buffer;\r\n    \r\n    buffer[0] = USER_COMMAND_PROMPT_ABILITIES;\r\n    \r\n    sendFormattedMessage(networkAddress, myMessage);\r\n    \r\n}\r\n\r\n\r\n// Notifications (general)\r\nvoid sendNotification(uint16 networkAddress, notification myNotification)\r\n{\r\n    message myMessage;\r\n    uint8 bufferLen = myNotification.numNotifications*5; // This will need to change for multiple messages...\r\n    uint8 i = 0;\r\n    uint8 buffer[bufferLen];\r\n    \r\n    // Populate message fields\r\n    myMessage.sourceLocale = myLocale();\r\n    myMessage.deviceType = MY_DEVICE_TYPE;\r\n    myMessage.messageCount = 0;//TODO: CALCULATE RQUIRED NUM OF MESSAGES!\r\n    myMessage.messageIndex = 0;\r\n    myMessage.messageType = MESSAGE_TYPE_NOTIFICATION;\r\n    myMessage.messageLength = bufferLen;\r\n    myMessage.messageData = buffer;\r\n    \r\n    buffer[0] = myNotification.numNotifications;\r\n    for (i = 0; i < myNotification.numNotifications; i++)\r\n    {\r\n        buffer[i*5+1] = (uint8) (myNotification.data[i] >> 24);\r\n        buffer[i*5+2] = (uint8) (myNotification.data[i] >> 16);\r\n        buffer[i*5+3] = (uint8) (myNotification.data[i] >> 8);\r\n        buffer[i*5+4] = (uint8) (myNotification.data[i] >> 0);\r\n        \r\n        buffer[i*5+1] = myNotification.type[i];\r\n        \r\n    }\r\n    \r\n    sendFormattedMessage(networkAddress, myMessage);\r\n    \r\n}\r\n\r\nvoid sendNotifications(uint8 numberOfDestinations, uint16 *networkAddresses, \r\n    notification myNotification)\r\n{\r\n    message myMessage;\r\n    uint8 bufferLen = myNotification.numNotifications*5; // This will need to change for multiple messages...\r\n    uint8 i = 0;\r\n    uint8 buffer[bufferLen];\r\n    \r\n    // Populate message fields\r\n    myMessage.sourceLocale = myLocale();\r\n    myMessage.deviceType = MY_DEVICE_TYPE;\r\n    myMessage.messageCount = 0;//TODO: CALCULATE RQUIRED NUM OF MESSAGES!\r\n    myMessage.messageIndex = 0;\r\n    myMessage.messageType = MESSAGE_TYPE_NOTIFICATION;\r\n    myMessage.messageLength = bufferLen;\r\n    myMessage.messageData = buffer;\r\n    \r\n    // Populate buffer\r\n    buffer[0] = myNotification.numNotifications;\r\n    for (i = 0; i < myNotification.numNotifications; i++)\r\n    {\r\n        buffer[i*5+1] = (uint8) (myNotification.data[i] >> 24);\r\n        buffer[i*5+2] = (uint8) (myNotification.data[i] >> 16);\r\n        buffer[i*5+3] = (uint8) (myNotification.data[i] >> 8);\r\n        buffer[i*5+4] = (uint8) (myNotification.data[i] >> 0);\r\n        \r\n        buffer[i*5+1] = myNotification.type[i];\r\n        \r\n    }\r\n    \r\n    for (i = 0; i < numberOfDestinations; i++)\r\n    {\r\n        sendFormattedMessage(networkAddresses[i], myMessage);\r\n        \r\n    }\r\n    \r\n}\r\n\r\n\r\n// Notification Request\r\nvoid sendNotificationRequest(uint16 networkAddress)\r\n{\r\n    message myMessage;\r\n    \r\n    // Populate message fields\r\n    myMessage.sourceLocale = myLocale();\r\n    myMessage.deviceType = MY_DEVICE_TYPE;\r\n    myMessage.messageCount = 0;\r\n    myMessage.messageIndex = 0;\r\n    myMessage.messageType = MESSAGE_TYPE_NOTIFICATION_REQUEST;\r\n    myMessage.messageLength = 0;\r\n    \r\n    sendFormattedMessage(networkAddress, myMessage);\r\n    \r\n}\r\n\r\n\r\n// Subscribe Request\r\nvoid sendSubscribeRequest(uint16 networkAddress)\r\n{\r\n    message myMessage;\r\n    \r\n    // Populate message fields\r\n    myMessage.sourceLocale = myLocale();\r\n    myMessage.deviceType = MY_DEVICE_TYPE;\r\n    myMessage.messageCount = 0;\r\n    myMessage.messageIndex = 0;\r\n    myMessage.messageType = MESSAGE_TYPE_SUBSCRIBE_REQUEST;\r\n    myMessage.messageLength = 0;\r\n    \r\n    sendFormattedMessage(networkAddress, myMessage);\r\n    \r\n}\r\n\r\n\r\n// Capability/Interest Notifications\r\nvoid sendCapabilitiesNotification(uint8 capabilitiesLength, \r\n    uint8 *capabilities)\r\n{\r\n    message myMessage;\r\n    uint8 buffer[capabilitiesLength];\r\n    uint8 i = 0;\r\n    \r\n    // Populate message fields\r\n    myMessage.sourceLocale = myLocale();\r\n    myMessage.deviceType = MY_DEVICE_TYPE;\r\n    myMessage.messageCount = 0;\r\n    myMessage.messageIndex = 0;\r\n    myMessage.messageType = MESSAGE_TYPE_CAPABILITY_NOTIFICATION;\r\n    myMessage.messageLength = 0;\r\n    myMessage.messageData = buffer;\r\n    \r\n    buffer[0] = capabilitiesLength;\r\n    for (i = 0; i < capabilitiesLength; i++)\r\n    {\r\n        buffer[i+1] = capabilities[i];\r\n        \r\n    }\r\n    \r\n    sendFormattedMessage(0, myMessage);\r\n    \r\n}\r\n\r\nvoid sendInterestsNotification(uint8 interestsLength, uint8 *interests,\r\n    uint8 *locales)\r\n{ // TODO: This will definitely need multi-spanning messages.\r\n    message myMessage;\r\n    uint8 buffer[2*interestsLength];\r\n    uint8 i = 0;\r\n    \r\n    // Populate message fields\r\n    myMessage.sourceLocale = myLocale();\r\n    myMessage.deviceType = MY_DEVICE_TYPE;\r\n    myMessage.messageCount = 0;\r\n    myMessage.messageIndex = 0;\r\n    myMessage.messageType = MESSAGE_TYPE_INTEREST_NOTIFICATION;\r\n    myMessage.messageLength = 0;\r\n    myMessage.messageData = buffer;\r\n    \r\n    buffer[0] = interestsLength;\r\n    for (i = 0; i < interestsLength; i++)\r\n    {\r\n        buffer[2*i+1] = interests[i];\r\n        buffer[2*i+2] = locales[i];\r\n    }\r\n    \r\n    sendFormattedMessage(0, myMessage);\r\n    \r\n}\r\n\r\n#IFDEF COORDINATOR\r\n// Subscribe Instruction\r\nvoid sendSubscribeInstruction(uint16 targetNetworkAddress, \r\n    uint16 networkAddress, uint32 macHi, uint32 macLow, uint8 locale, \r\n    uint8 numCapabilities, uint8 *capabilities)\r\n{\r\n    message myMessage;\r\n    uint8 buffer[12 + numCapabilites];\r\n    uint8 i = 0;\r\n    \r\n    // Populate message fields\r\n    myMessage.sourceLocale = myLocale();\r\n    myMessage.deviceType = MY_DEVICE_TYPE;\r\n    myMessage.messageCount = 0;\r\n    myMessage.messageIndex = 0;\r\n    myMessage.messageType = MESSAGE_TYPE_SUBSCRIBE_INSTRUCTION;\r\n    myMessage.messageLength = 12 + numCapabilities;\r\n    myMessage.messageData = buffer;\r\n    \r\n    buffer[0] = (uint8)(networkAddress >> 8);\r\n    buffer[1] = (uint8)(networkAddres);\r\n    buffer[2] = (uint8)(macHi >> 24);\r\n    buffer[3] = (uint8)(macHi >> 16);\r\n    buffer[4] = (uint8)(macHi >> 8);\r\n    buffer[5] = (uint8)(macHi >> 0);\r\n    buffer[6] = (uint8)(macLow >> 24);\r\n    buffer[7] = (uint8)(macLow >> 16);\r\n    buffer[8] = (uint8)(macLow >> 8);\r\n    buffer[9] = (uint8)(macLow >> 0);\r\n    buffer[10] = locale;\r\n    buffer[11] = numCapabilities;\r\n    for (i = 0; i < numCapabilities; i++)\r\n    {\r\n        buffer[i+12] = capabilities[i];\r\n    }\r\n    \r\n    sendFormattedMessage(targetNetworkAddress, myMessage);\r\n}\r\n\r\n#ENDIF\r\n\r\n// Safety Alarms\r\nvoid sendSafetyAlarm(uint8 riskType, uint8 riskLocale)\r\n{\r\n    // TODO: add something for possible universale risk locale? (0?)\r\n    message myMessage;\r\n    \r\n    getNodesInLocale(riskLocale, nodesInLocale);\r\n    \r\n    // Populate message fields\r\n    myMessage.sourceLocale = myLocale();\r\n    myMessage.deviceType = MY_DEVICE_TYPE;\r\n    myMessage.messageCount = 0;\r\n    myMessage.messageIndex = 0;\r\n    myMessage.messageType = MESSAGE_TYPE_SAFETY_ALARM;\r\n    myMessage.messageLength = 0;\r\n    \r\n    for (i = 0; i < MY_ADDRESS_BOOK_LENGTH; i++)\r\n    {\r\n        if (addressBook[i].locale == riskLocale)\r\n        {\r\n            sendFormattedMessage(addressBook[i].networkAddress, myMessage);\r\n            \r\n        }\r\n        \r\n    }\r\n    \r\n    // Send safety alert to coordinator for good measure\r\n    sendFormattedMessage(0, myMessage);\r\n    \r\n}\r\n\r\n// Scans the address book for nodes that are interested in data contained in the\r\n// passed in notification and sends data to these nodes.  Returns the number of\r\n// nodes notified.\r\nuint8 notifyInterestedNodes(notification myNotification)\r\n{\r\n    uint8 i = 0, j = 0, k = 0, numNotified = 0;\r\n    notification N;\r\n    int32 data[myNotification.numNotifications];\r\n    int8 types[myNotification.numNotifications];\r\n    N.data = data;\r\n    N.types = types;\r\n    \r\n    for (i = 0; i < MY_ADDRESS_BOOK_LENGTH; i++)\r\n    {\r\n        if (addressBook[i].locale != 0)\r\n        {\r\n            // For each entry in the address book, construct a notification \r\n            // containing data that entry is interested in\r\n            N.numNotifications = 0;\r\n            \r\n            for (j = 0; j < myNotification.numNotifications; j++)\r\n            {\r\n                // For each notification in the passed in notification, check\r\n                // if this entry is interested in it\r\n                \r\n                for (k = 0; k < addressBook[i].numInterests; k++)\r\n                {\r\n                    // For each interest in this entry, check if the passed in \r\n                    // notification is equal to it\r\n                    \r\n                    if (addressBook[i].interests[k] == myNotification.types[j])\r\n                    {\r\n                        // If entry is interested, add this data to the notification\r\n                        N.data[N.numNotifications] = myNotification.data[j];\r\n                        N.types[N.numNotifications] = myNotification.types[j];\r\n                        N.numNotifications += 1;\r\n                        \r\n                        // Exit k for loop (this data type has been handled)\r\n                        break;\r\n                        \r\n                    }\r\n                    \r\n                }\r\n                \r\n            }\r\n            \r\n        }\r\n        \r\n        // Check if this entry is interested in anything from the notification\r\n        if (N.numNotifications > 0)\r\n        {\r\n            // Send constructed notification\r\n            sendNotificaiton(addressBook[i].networkAddress, N);\r\n            numNotified += 1;\r\n            \r\n        }\r\n        \r\n    }\r\n    \r\n    return numNotified;\r\n    \r\n}"]],"start1":0,"start2":0,"length1":0,"length2":12907}]],"length":12907}
{"contributors":[],"silentsave":false,"ts":1352707256340,"patch":[[{"diffs":[[1,"\r\n\r\n#include <whan_protocol.h>\r\n\r\n// This function is for interfacing with the UART interface\r\nvoid sendMessage(uint32 macHi, uint32 macLow, uint16 networkAddress, \r\n    uint8 rfDataLength, uint8 rfData[])\r\n{\r\n    \r\n    // TODO: fill in this function to tie it to the system UART\r\n    // It should implement the Zigbee Send Request command\r\n    \r\n}\r\n\r\n// Get message from the receive buffer and put it into the passed in variables\r\nvoid getMessage(uint32 *macHi, uint32 *macLow, uint16 *networkAddress,\r\n    uint8 *rfData)\r\n{\r\n    \r\n    // TODO: fill in this function to tie it to the system UART\r\n    // It should implement the Zigbee Receive Packet command\r\n    \r\n}\r\n\r\n// Get message length (the length of rfData)\r\nuint8 getMessageLength(void)\r\n{\r\n    \r\n    // TODO: fill in this function to allow host processor to allocate\r\n    // proper amount of memory for getMessage command.\r\n    \r\n}\r\n\r\n// This function is called by the top level functions, and integrates with the\r\n// lower level sendMessage() function\r\nvoid sendFormattedMessage(uint16 networkAddress, message myMessage)\r\n{\r\n    uint8 i = 0;\r\n    uint32 macLow = getMacLow(networkAddress);\r\n    uint32 macHigh = getMacHigh(networkAddress);\r\n    uint8 rfDataLength = myMessage.messageLength + 7;\r\n    uint8 messageBuffer[rfDataLength];\r\n    \r\n    messageBuffer[0] = myMessage.sourceLocale;\r\n    messageBuffer[1] = (uint8)(myMessage.sourceDeviceType);\r\n    messageBuffer[2] = (uint8)(myMessage.sourceDeviceType >> 8);\r\n    messageBuffer[3] = myMessage.messageCount;\r\n    messageBuffer[4] = myMessage.messageIndex;\r\n    messageBuffer[5] = myMessage.messageType;\r\n    messageBuffer[6] = myMessage.messageLength;\r\n    \r\n    for (i = 0; i < messageLength; i++) \r\n    {\r\n        messageBuffer[i+7] = myMessage.messageData[i];\r\n        \r\n    }\r\n    \r\n    sendMessage(macHigh, macLow, networkAddress, rfDataLength, messageBuffer);\r\n    \r\n}\r\n\r\n// Gets the message type, allowing for branching based on what was received\r\nuint8 getMessageType(uint8 *messageData)\r\n{\r\n    return messageData[5];\r\n    \r\n}\r\n\r\n// User Commands\r\nvoid sendUserCommandChangeValue(uint16 networkAddr, uint8 targetValueType, \r\n    uint32 targetValueData)\r\n{\r\n    message myMessage;\r\n    uint8 buffer[6];\r\n    \r\n    // Populate message fields\r\n    myMessage.sourceLocale = myLocale();\r\n    myMessage.deviceType = MY_DEVICE_TYPE;\r\n    myMessage.messageCount = 0;\r\n    myMessage.messageIndex = 0;\r\n    myMessage.messageType = MESSAGE_TYPE_USER_COMMAND;\r\n    myMessage.messageLength = 6;\r\n    myMessage.messageData = buffer;\r\n    \r\n    // Populate data buffer\r\n    buffer[0] = USER_COMMAND_CHANGE_VALUE;\r\n    buffer[1] = targetValueType;\r\n    buffer[2] = (uint8) ()targetValueData >> 24); // Big endian transmission\r\n    buffer[3] = (uint8) ()targetValueData >> 16);\r\n    buffer[4] = (uint8) ()targetValueData >> 8);\r\n    buffer[5] = (uint8) ()targetValueData >> 0);\r\n    \r\n    sendFormattedMessage(targetAddr, myMessage);\r\n    \r\n}\r\n    \r\nvoid sendUserCommandPromptAbilities(uint16 networkAddress)\r\n{\r\n    message myMessage;\r\n    uint8 buffer[1];\r\n    \r\n    // Populate message fields\r\n    myMessage.sourceLocale = myLocale();\r\n    myMessage.deviceType = MY_DEVICE_TYPE;\r\n    myMessage.messageCount = 0;\r\n    myMessage.messageIndex = 0;\r\n    myMessage.messageType = MESSAGE_TYPE_USER_COMMAND;\r\n    myMessage.messageLength = 1;\r\n    myMessage.messageData = buffer;\r\n    \r\n    buffer[0] = USER_COMMAND_PROMPT_ABILITIES;\r\n    \r\n    sendFormattedMessage(networkAddress, myMessage);\r\n    \r\n}\r\n\r\n\r\n// Notifications (general)\r\nvoid sendNotification(uint16 networkAddress, notification myNotification)\r\n{\r\n    message myMessage;\r\n    uint8 bufferLen = myNotification.numNotifications*5; // This will need to change for multiple messages...\r\n    uint8 i = 0;\r\n    uint8 buffer[bufferLen];\r\n    \r\n    // Populate message fields\r\n    myMessage.sourceLocale = myLocale();\r\n    myMessage.deviceType = MY_DEVICE_TYPE;\r\n    myMessage.messageCount = 0;//TODO: CALCULATE RQUIRED NUM OF MESSAGES!\r\n    myMessage.messageIndex = 0;\r\n    myMessage.messageType = MESSAGE_TYPE_NOTIFICATION;\r\n    myMessage.messageLength = bufferLen;\r\n    myMessage.messageData = buffer;\r\n    \r\n    buffer[0] = myNotification.numNotifications;\r\n    for (i = 0; i < myNotification.numNotifications; i++)\r\n    {\r\n        buffer[i*5+1] = (uint8) (myNotification.data[i] >> 24);\r\n        buffer[i*5+2] = (uint8) (myNotification.data[i] >> 16);\r\n        buffer[i*5+3] = (uint8) (myNotification.data[i] >> 8);\r\n        buffer[i*5+4] = (uint8) (myNotification.data[i] >> 0);\r\n        \r\n        buffer[i*5+1] = myNotification.type[i];\r\n        \r\n    }\r\n    \r\n    sendFormattedMessage(networkAddress, myMessage);\r\n    \r\n}\r\n\r\nvoid sendNotifications(uint8 numberOfDestinations, uint16 *networkAddresses, \r\n    notification myNotification)\r\n{\r\n    message myMessage;\r\n    uint8 bufferLen = myNotification.numNotifications*5; // This will need to change for multiple messages...\r\n    uint8 i = 0;\r\n    uint8 buffer[bufferLen];\r\n    \r\n    // Populate message fields\r\n    myMessage.sourceLocale = myLocale();\r\n    myMessage.deviceType = MY_DEVICE_TYPE;\r\n    myMessage.messageCount = 0;//TODO: CALCULATE RQUIRED NUM OF MESSAGES!\r\n    myMessage.messageIndex = 0;\r\n    myMessage.messageType = MESSAGE_TYPE_NOTIFICATION;\r\n    myMessage.messageLength = bufferLen;\r\n    myMessage.messageData = buffer;\r\n    \r\n    // Populate buffer\r\n    buffer[0] = myNotification.numNotifications;\r\n    for (i = 0; i < myNotification.numNotifications; i++)\r\n    {\r\n        buffer[i*5+1] = (uint8) (myNotification.data[i] >> 24);\r\n        buffer[i*5+2] = (uint8) (myNotification.data[i] >> 16);\r\n        buffer[i*5+3] = (uint8) (myNotification.data[i] >> 8);\r\n        buffer[i*5+4] = (uint8) (myNotification.data[i] >> 0);\r\n        \r\n        buffer[i*5+1] = myNotification.type[i];\r\n        \r\n    }\r\n    \r\n    for (i = 0; i < numberOfDestinations; i++)\r\n    {\r\n        sendFormattedMessage(networkAddresses[i], myMessage);\r\n        \r\n    }\r\n    \r\n}\r\n\r\n\r\n// Notification Request\r\nvoid sendNotificationRequest(uint16 networkAddress)\r\n{\r\n    message myMessage;\r\n    \r\n    // Populate message fields\r\n    myMessage.sourceLocale = myLocale();\r\n    myMessage.deviceType = MY_DEVICE_TYPE;\r\n    myMessage.messageCount = 0;\r\n    myMessage.messageIndex = 0;\r\n    myMessage.messageType = MESSAGE_TYPE_NOTIFICATION_REQUEST;\r\n    myMessage.messageLength = 0;\r\n    \r\n    sendFormattedMessage(networkAddress, myMessage);\r\n    \r\n}\r\n\r\n\r\n// Subscribe Request\r\nvoid sendSubscribeRequest(uint16 networkAddress)\r\n{\r\n    message myMessage;\r\n    \r\n    // Populate message fields\r\n    myMessage.sourceLocale = myLocale();\r\n    myMessage.deviceType = MY_DEVICE_TYPE;\r\n    myMessage.messageCount = 0;\r\n    myMessage.messageIndex = 0;\r\n    myMessage.messageType = MESSAGE_TYPE_SUBSCRIBE_REQUEST;\r\n    myMessage.messageLength = 0;\r\n    \r\n    sendFormattedMessage(networkAddress, myMessage);\r\n    \r\n}\r\n\r\n\r\n// Capability/Interest Notifications\r\nvoid sendCapabilitiesNotification(uint8 capabilitiesLength, \r\n    uint8 *capabilities)\r\n{\r\n    message myMessage;\r\n    uint8 buffer[capabilitiesLength];\r\n    uint8 i = 0;\r\n    \r\n    // Populate message fields\r\n    myMessage.sourceLocale = myLocale();\r\n    myMessage.deviceType = MY_DEVICE_TYPE;\r\n    myMessage.messageCount = 0;\r\n    myMessage.messageIndex = 0;\r\n    myMessage.messageType = MESSAGE_TYPE_CAPABILITY_NOTIFICATION;\r\n    myMessage.messageLength = 0;\r\n    myMessage.messageData = buffer;\r\n    \r\n    buffer[0] = capabilitiesLength;\r\n    for (i = 0; i < capabilitiesLength; i++)\r\n    {\r\n        buffer[i+1] = capabilities[i];\r\n        \r\n    }\r\n    \r\n    sendFormattedMessage(0, myMessage);\r\n    \r\n}\r\n\r\nvoid sendInterestsNotification(uint8 interestsLength, uint8 *interests,\r\n    uint8 *locales)\r\n{ // TODO: This will definitely need multi-spanning messages.\r\n    message myMessage;\r\n    uint8 buffer[2*interestsLength];\r\n    uint8 i = 0;\r\n    \r\n    // Populate message fields\r\n    myMessage.sourceLocale = myLocale();\r\n    myMessage.deviceType = MY_DEVICE_TYPE;\r\n    myMessage.messageCount = 0;\r\n    myMessage.messageIndex = 0;\r\n    myMessage.messageType = MESSAGE_TYPE_INTEREST_NOTIFICATION;\r\n    myMessage.messageLength = 0;\r\n    myMessage.messageData = buffer;\r\n    \r\n    buffer[0] = interestsLength;\r\n    for (i = 0; i < interestsLength; i++)\r\n    {\r\n        buffer[2*i+1] = interests[i];\r\n        buffer[2*i+2] = locales[i];\r\n    }\r\n    \r\n    sendFormattedMessage(0, myMessage);\r\n    \r\n}\r\n\r\n#IFDEF COORDINATOR\r\n// Subscribe Instruction\r\nvoid sendSubscribeInstruction(uint16 targetNetworkAddress, \r\n    uint16 networkAddress, uint32 macHi, uint32 macLow, uint8 locale, \r\n    uint8 numCapabilities, uint8 *capabilities)\r\n{\r\n    message myMessage;\r\n    uint8 buffer[12 + numCapabilites];\r\n    uint8 i = 0;\r\n    \r\n    // Populate message fields\r\n    myMessage.sourceLocale = myLocale();\r\n    myMessage.deviceType = MY_DEVICE_TYPE;\r\n    myMessage.messageCount = 0;\r\n    myMessage.messageIndex = 0;\r\n    myMessage.messageType = MESSAGE_TYPE_SUBSCRIBE_INSTRUCTION;\r\n    myMessage.messageLength = 12 + numCapabilities;\r\n    myMessage.messageData = buffer;\r\n    \r\n    buffer[0] = (uint8)(networkAddress >> 8);\r\n    buffer[1] = (uint8)(networkAddres);\r\n    buffer[2] = (uint8)(macHi >> 24);\r\n    buffer[3] = (uint8)(macHi >> 16);\r\n    buffer[4] = (uint8)(macHi >> 8);\r\n    buffer[5] = (uint8)(macHi >> 0);\r\n    buffer[6] = (uint8)(macLow >> 24);\r\n    buffer[7] = (uint8)(macLow >> 16);\r\n    buffer[8] = (uint8)(macLow >> 8);\r\n    buffer[9] = (uint8)(macLow >> 0);\r\n    buffer[10] = locale;\r\n    buffer[11] = numCapabilities;\r\n    for (i = 0; i < numCapabilities; i++)\r\n    {\r\n        buffer[i+12] = capabilities[i];\r\n    }\r\n    \r\n    sendFormattedMessage(targetNetworkAddress, myMessage);\r\n}\r\n\r\n#ENDIF\r\n\r\n// Safety Alarms\r\nvoid sendSafetyAlarm(uint8 riskType, uint8 riskLocale)\r\n{\r\n    // TODO: add something for possible universale risk locale? (0?)\r\n    message myMessage;\r\n    \r\n    getNodesInLocale(riskLocale, nodesInLocale);\r\n    \r\n    // Populate message fields\r\n    myMessage.sourceLocale = myLocale();\r\n    myMessage.deviceType = MY_DEVICE_TYPE;\r\n    myMessage.messageCount = 0;\r\n    myMessage.messageIndex = 0;\r\n    myMessage.messageType = MESSAGE_TYPE_SAFETY_ALARM;\r\n    myMessage.messageLength = 0;\r\n    \r\n    for (i = 0; i < MY_ADDRESS_BOOK_LENGTH; i++)\r\n    {\r\n        if (addressBook[i].locale == riskLocale)\r\n        {\r\n            sendFormattedMessage(addressBook[i].networkAddress, myMessage);\r\n            \r\n        }\r\n        \r\n    }\r\n    \r\n    // Send safety alert to coordinator for good measure\r\n    sendFormattedMessage(0, myMessage);\r\n    \r\n}\r\n\r\n// Scans the address book for nodes that are interested in data contained in the\r\n// passed in notification and sends data to these nodes.  Returns the number of\r\n// nodes notified.\r\nuint8 notifyInterestedNodes(notification myNotification)\r\n{\r\n    uint8 i = 0, j = 0, k = 0, numNotified = 0;\r\n    notification N;\r\n    int32 data[myNotification.numNotifications];\r\n    int8 types[myNotification.numNotifications];\r\n    N.data = data;\r\n    N.types = types;\r\n    \r\n    for (i = 0; i < MY_ADDRESS_BOOK_LENGTH; i++)\r\n    {\r\n        if (addressBook[i].locale != 0)\r\n        {\r\n            // For each entry in the address book, construct a notification \r\n            // containing data that entry is interested in\r\n            N.numNotifications = 0;\r\n            \r\n            for (j = 0; j < myNotification.numNotifications; j++)\r\n            {\r\n                // For each notification in the passed in notification, check\r\n                // if this entry is interested in it\r\n                \r\n                for (k = 0; k < addressBook[i].numInterests; k++)\r\n                {\r\n                    // For each interest in this entry, check if the passed in \r\n                    // notification is equal to it\r\n                    \r\n                    if (addressBook[i].interests[k] == myNotification.types[j])\r\n                    {\r\n                        // If entry is interested, add this data to the notification\r\n                        N.data[N.numNotifications] = myNotification.data[j];\r\n                        N.types[N.numNotifications] = myNotification.types[j];\r\n                        N.numNotifications += 1;\r\n                        \r\n                        // Exit k for loop (this data type has been handled)\r\n                        break;\r\n                        \r\n                    }\r\n                    \r\n                }\r\n                \r\n            }\r\n            \r\n        }\r\n        \r\n        // Check if this entry is interested in anything from the notification\r\n        if (N.numNotifications > 0)\r\n        {\r\n            // Send constructed notification\r\n            sendNotificaiton(addressBook[i].networkAddress, N);\r\n            numNotified += 1;\r\n            \r\n        }\r\n        \r\n    }\r\n    \r\n    return numNotified;\r\n    \r\n}"]],"start1":0,"start2":0,"length1":0,"length2":12907}]],"length":12907,"saved":false}
{"contributors":[],"silentsave":true,"ts":1352707341547,"patch":[[{"diffs":[[0,"age "],[-1,"command.\r\n    \r\n}\r\n\r\n// This function is called by the top level functions, and integrates with the\r\n// lower level sendMessage() function\r\nvoid sendFormattedMessage(uint16 networkAddress, message myMessage)\r\n{\r\n    uint8 i = 0;\r\n    uint32 macLow = getMacLow(networkAddress);\r\n    uint32 macHigh = getMacHigh(networkAddress);\r\n    uint8 rfDataLength = myMessage.messageLength + 7;\r\n    uint8 messageBuffer[rfDataLength];\r\n    \r\n    messageBuffer[0] = myMessage.sourceLocale;\r\n    messageBuffer[1] = (uint8)(myMessage.sourceDeviceType);\r\n    messageBuffer[2] = (uint8)(myMessage.sourceDeviceType >> 8);\r\n    messageBuffer[3] = myMessage.messageCount;\r\n    messageBuffer[4] = myMessage.messageIndex;\r\n    messageBuffer[5] = myMessage.messageType;\r\n    messageBuffer[6] = myMessage.messageLength;\r\n    \r\n    for (i = 0; i < messageLength; i++) \r\n    {\r\n        messageBuffer[i+7] = myMessage.messageData[i];\r\n        \r\n    }\r\n    \r\n    sendMessage(macHigh, macLow, networkAddress, rfDataLength, messageBuffer);\r\n    \r\n}\r\n\r\n// Gets the message type, allowing for branching based on what was received\r\nuint8 getMessageType(uint8 *messageData)\r\n{\r\n    return messageData[5];\r\n    \r\n}\r\n\r\n// User Commands\r\nvoid sendUserCommandChangeValue(uint16 networkAddr, uint8 targetValueType, \r\n    uint32 targetValueData)\r\n{\r\n    message myMessage;\r\n    uint8 buffer[6];\r\n    \r\n    // Populate message fields\r\n    myMessage.sourceLocale = myLocale();\r\n    myMessage.deviceType = MY_DEVICE_TYPE;\r\n    myMessage.messageCount = 0;\r\n    myMessage.messageIndex = 0;\r\n    myMessage.messageType = MESSAGE_TYPE_USER_COMMAND;\r\n    myMessage.messageLength = 6;\r\n    myMessage.messageData = buffer;\r\n    \r\n    // Populate data buffer\r\n    buffer[0] = USER_COMMAND_CHANGE_VALUE;\r\n    buffer[1] = targetValueType;\r\n    buffer[2] = (uint8) ()targetValueData >> 24); // Big endian transmission\r\n    buffer[3] = (uint8) ()targetValueData >> 16);\r\n    buffer[4] = (uint8) ()targetValueData >> 8);\r\n    buffer[5] = (uint8) ()targetValueData >> 0);\r\n    \r\n    sendFormattedMessage(targetAddr, myMessage);\r\n    \r\n}\r\n    \r\nvoid sendUserCommandPromptAbilities(uint16 networkAddress)\r\n{\r\n    message myMessage;\r\n    uint8 buffer[1];\r\n    \r\n    // Populate message fields\r\n    myMessage.sourceLocale = myLocale();\r\n    myMessage.deviceType = MY_DEVICE_TYPE;\r\n    myMessage.messageCount = 0;\r\n    myMessage.messageIndex = 0;\r\n    myMessage.messageType = MESSAGE_TYPE_USER_COMMAND;\r\n    myMessage.messageLength = 1;\r\n    myMessage.messageData = buffer;\r\n    \r\n    buffer[0] = USER_COMMAND_PROMPT_ABILITIES;\r\n    \r\n    sendFormattedMessage(networkAddress, myMessage);\r\n    \r\n}\r\n\r\n\r\n// Notifications (general)\r\nvoid sendNotification(uint16 networkAddress, notification myNotification)\r\n{\r\n    message myMessage;\r\n    uint8 bufferLen = myNotification.numNotifications*5; // This will need to change for multiple messages...\r\n    uint8 i = 0;\r\n    uint8 buffer[bufferLen];\r\n    \r\n    // Populate message fields\r\n    myMessage.sourceLocale = myLocale();\r\n    myMessage.deviceType = MY_DEVICE_TYPE;\r\n    myMessage.messageCount = 0;//TODO: CALCULATE RQUIRED NUM OF MESSAGES!\r\n    myMessage.messageIndex = 0;\r\n    myMessage.messageType = MESSAGE_TYPE_NOTIFICATION;\r\n    myMessage.messageLength = bufferLen;\r\n    myMessage.messageData = buffer;\r\n    \r\n    buffer[0] = myNotification.numNotifications;\r\n    for (i = 0; i < myNotification.numNotifications; i++)\r\n    {\r\n        buffer[i*5+1] = (uint8) (myNotification.data[i] >> 24);\r\n        buffer[i*5+2] = (uint8) (myNotification.data[i] >> 16);\r\n        buffer[i*5+3] = (uint8) (myNotification.data[i] >> 8);\r\n        buffer[i*5+4] = (uint8) (myNotification.data[i] >> 0);\r\n        \r\n        buffer[i*5+1] = myNotification.type[i];\r\n        \r\n    }\r\n    \r\n    sendFormattedMessage(networkAddress, myMessage);\r\n    \r\n}\r\n\r\nvoid sendNotifications(uint8 numberOfDestinations, uint16 *networkAddresses, \r\n    notification myNotification)\r\n{\r\n    message myMessage;\r\n    uint8 bufferLen = myNotification.numNotifications*5; // This will need to change for multiple messages...\r\n    uint8 i = 0;\r\n    uint8 buffer[bufferLen];\r\n    \r\n    // Populate message fields\r\n    myMessage.sourceLocale = myLocale();\r\n    myMessage.deviceType = MY_DEVICE_TYPE;\r\n    myMessage.messageCount = 0;//TODO: CALCULATE RQUIRED NUM OF MESSAGES!\r\n    myMessage.messageIndex = 0;\r\n    myMessage.messageType = MESSAGE_TYPE_NOTIFICATION;\r\n    myMessage.messageLength = bufferLen;\r\n    myMessage.messageData = buffer;\r\n    \r\n    // Populate buffer\r\n    buffer[0] = myNotification.numNotifications;\r\n    for (i = 0; i < myNotification.numNotifications; i++)\r\n    {\r\n        buffer[i*5+1] = (uint8) (myNotification.data[i] >> 24);\r\n        buffer[i*5+2] = (uint8) (myNotification.data[i] >> 16);\r\n        buffer[i*5+3] = (uint8) (myNotification.data[i] >> 8);\r\n        buffer[i*5+4] = (uint8) (myNotification.data[i] >> 0);\r\n        \r\n        buffer[i*5+1] = myNotification.type[i];\r\n        \r\n    }\r\n    \r\n    for (i = 0; i < numberOfDestinations; i++)\r\n    {\r\n        sendFormattedMessage(networkAddresses[i], myMessage);\r\n        \r\n    }\r\n    \r\n}\r\n\r\n\r\n// Notification Request\r\nvoid sendNotificationRequest(uint16 networkAddress)\r\n{\r\n    message myMessage;\r\n    \r\n    // Populate message fields\r\n    myMessage.sourceLocale = myLocale();\r\n    myMessage.deviceType = MY_DEVICE_TYPE;\r\n    myMessage.messageCount = 0;\r\n    myMessage.messageIndex = 0;\r\n    myMessage.messageType = MESSAGE_TYPE_NOTIFICATION_REQUEST;\r\n    myMessage.messageLength = 0;\r\n    \r\n    sendFormattedMessage(networkAddress, myMessage);\r\n    \r\n}\r\n\r\n\r\n// Subscribe Request\r\nvoid sendSubscribeRequest(uint16 networkAddress)\r\n{\r\n    message myMessage;\r\n    \r\n    // Populate message fields\r\n    myMessage.sourceLocale = myLocale();\r\n    myMessage.deviceType = MY_DEVICE_TYPE;\r\n    myMessage.messageCount = 0;\r\n    myMessage.messageIndex = 0;\r\n    myMessage.messageType = MESSAGE_TYPE_SUBSCRIBE_REQUEST;\r\n    myMessage.messageLength = 0;\r\n    \r\n    sendFormattedMessage(networkAddress, myMessage);\r\n    \r\n}\r\n\r\n\r\n// Capability/Interest Notifications\r\nvoid sendCapabilitiesNotification(uint8 capabilitiesLength, \r\n    uint8 *capabilities)\r\n{\r\n    message myMessage;\r\n    uint8 buffer[capabilitiesLength];\r\n    uint8 i = 0;\r\n    \r\n    // Populate message fields\r\n    myMessage.sourceLocale = myLocale();\r\n    myMessage.deviceType = MY_DEVICE_TYPE;\r\n    myMessage.messageCount = 0;\r\n    myMessage.messageIndex = 0;\r\n    myMessage.messageType = MESSAGE_TYPE_CAPABILITY_NOTIFICATION;\r\n    myMessage.messageLength = 0;\r\n    myMessage.messageData = buffer;\r\n    \r\n    buffer[0] = capabilitiesLength;\r\n    for (i = 0; i < capabilitiesLength; i++)\r\n    {\r\n        buffer[i+1] = capabilities[i];\r\n        \r\n    }\r\n    \r\n    sendFormattedMessage(0, myMessage);\r\n    \r\n}\r\n\r\nvoid sendInterestsNotification(uint8 interestsLength, uint8 *interests,\r\n    uint8 *locales)\r\n{ // TODO: This will definitely need multi-spanning messages.\r\n    message myMessage;\r\n    uint8 buffer[2*interestsLength];\r\n    uint8 i = 0;\r\n    \r\n    // Populate message fields\r\n    myMessage.sourceLocale = myLocale();\r\n    myMessage.deviceType = MY_DEVICE_TYPE;\r\n    myMessage.messageCount = 0;\r\n    myMessage.messageIndex = 0;\r\n    myMessage.messageType = MESSAGE_TYPE_INTEREST_NOTIFICATION;\r\n    myMessage.messageLength = 0;\r\n    myMessage.messageData = buffer;\r\n    \r\n    buffer[0] = interestsLength;\r\n    for (i = 0; i < interestsLength; i++)\r\n    {\r\n        buffer[2*i+1] = interests[i];\r\n        buffer[2*i+2] = locales[i];\r\n    }\r\n    \r\n    sendFormattedMessage(0, myMessage);\r\n    \r\n}\r\n\r\n#IFDEF COORDINATOR\r\n// Subscribe Instruction\r\nvoid sendSubscribeInstruction(uint16 targetNetworkAddress, \r\n    uint16 networkAddress, uint32 macHi, uint32 macLow, uint8 locale, \r\n    uint8 numCapabilities, uint8 *capabilities)\r\n{\r\n    message myMessage;\r\n    uint8 buffer[12 + numCapabilites];\r\n    uint8 i = 0;\r\n    \r\n    // Populate message fields\r\n    myMessage.sourceLocale = myLocale();\r\n    myMessage.deviceType = MY_DEVICE_TYPE;\r\n    myMessage.messageCount = 0;\r\n    myMessage.messageIndex = 0;\r\n    myMessage.messageType = MESSAGE_TYPE_SUBSCRIBE_INSTRUCTION;\r\n    myMessage.messageLength = 12 + numCapabilities;\r\n    myMessage.messageData = buffer;\r\n    \r\n    buffer[0] = (uint8)(networkAddress >> 8);\r\n    buffer[1] = (uint8)(networkAddres);\r\n    buffer[2] = (uint8)(macHi >> 24);\r\n    buffer[3] = (uint8)(macHi >> 16);\r\n    buffer[4] = (uint8)(macHi >> 8);\r\n    buffer[5] = (uint8)(macHi >> 0);\r\n    buffer[6] = (uint8)(macLow >> 24);\r\n    buffer[7] = (uint8)(macLow >> 16);\r\n    buffer[8] = (uint8)(macLow >> 8);\r\n    buffer[9] = (uint8)(macLow >> 0);\r\n    buffer[10] = locale;\r\n    buffer[11] = numCapabilities;\r\n    for (i = 0; i < numCapabilities; i++)\r\n    {\r\n        buffer[i+12] = capabilities[i];\r\n    }\r\n    \r\n    sendFormattedMessage(targetNetworkAddress, myMessage);\r\n}\r\n\r\n#ENDIF\r\n\r\n// Safety Alarms\r\nvoid sendSafetyAlarm(uint8 riskType, uint8 riskLocale)\r\n{\r\n    // TODO: add something for possible universale risk locale? (0?)\r\n    message myMessage;\r\n    \r\n    getNodesInLocale(riskLocale, nodesInLocale);\r\n    \r\n    // Populate message fields\r\n    myMessage.sourceLocale = myLocale();\r\n    myMessage.deviceType = MY_DEVICE_TYPE;\r\n    myMessage.messageCount = 0;\r\n    myMessage.messageIndex = 0;\r\n    myMessage.messageType = MESSAGE_TYPE_SAFETY_ALARM;\r\n    myMessage.messageLength = 0;\r\n    \r\n    for (i = 0; i < MY_ADDRESS_BOOK_LENGTH; i++)\r\n    {\r\n        if (addressBook[i].locale == riskLocale)\r\n        {\r\n            sendFormattedMessage(addressBook[i].networkAddress, myMessage);\r\n            \r\n        }\r\n        \r\n    }\r\n    \r\n    // Send safety alert to coordinator for good measure\r\n    sendFormattedMessage(0, myMessage);\r\n    \r\n}\r\n\r\n// Scans the address book for nodes that are interested in data contained in the\r\n// passed in notification and sends data to these nodes.  Returns the number of\r\n// nodes notified.\r\nuint8 notifyInterestedNodes(notification myNotification)\r\n{\r\n    uint8 i = 0, j = 0, k = 0, numNotified = 0;\r\n    notification N;\r\n    int32 data[myNotification.numNotifications];\r\n    int8 types[myNotification.numNotifications];\r\n    N.data = data;\r\n    N.types = types;\r\n    \r\n    for (i = 0; i < MY_ADDRESS_BOOK_LENGTH; i++)\r\n    {\r\n        if (addressBook[i].locale != 0)\r\n        {\r\n            // For each entry in the address book, construct a notification \r\n            // containing data that entry is interested in\r\n            N.numNotifications = 0;\r\n            \r\n            for (j = 0; j < myNotification.numNotifications; j++)\r\n            {\r\n                // For each notification in the passed in notification, check\r\n                // if this entry is interested in it\r\n                \r\n                for (k = 0; k < addressBook[i].numInterests; k++)\r\n                {\r\n                    // For each interest in this entry, check if the passed in \r\n                    // notification is equal to it\r\n                    \r\n                    if (addressBook[i].interests[k] == myNotification.types[j])\r\n                    {\r\n                        // If entry is interested, add this data to the notification\r\n                        N.data[N.numNotifications] = myNotification.data[j];\r\n                        N.types[N.numNotifications] = myNotification.types[j];\r\n                        N.numNotifications += 1;\r\n                        \r\n                        // Exit k for loop (this data type has been handled)\r\n                        break;\r\n                        \r\n                    }\r\n                    \r\n                }\r\n                \r\n            }\r\n            \r\n        }\r\n        \r\n        // Check if this entry is interested in anything from the notification\r\n        if (N.numNotifications > 0)\r\n        {\r\n            // Send constructed notification\r\n            sendNotificaiton(addressBook[i].networkAddress, N);\r\n            numNotified += 1;\r\n            \r\n        }\r\n        \r\n    }\r\n    \r\n    return numNotified;\r\n    \r\n}\r\n\r\n#include <whan_protocol.h>\r\n\r\n// This function is for interfacing with the UART interface\r\nvoid sendMessage(uint32 macHi, uint32 macLow, uint16 networkAddress, \r\n    uint8 rfDataLength, uint8 rfData[])\r\n{\r\n    \r\n    // TODO: fill in this function to tie it to the system UART\r\n    // It should implement the Zigbee Send Request command\r\n    \r\n}\r\n\r\n// Get message from the receive buffer and put it into the passed in variables\r\nvoid getMessage(uint32 *macHi, uint32 *macLow, uint16 *networkAddress,\r\n    uint8 *rfData)\r\n{\r\n    \r\n    // TODO: fill in this function to tie it to the system UART\r\n    // It should implement the Zigbee Receive Packet command\r\n    \r\n}\r\n\r\n// Get message length (the length of rfData)\r\nuint8 getMessageLength(void)\r\n{\r\n    \r\n    // TODO: fill in this function to allow host processor to allocate\r\n    // proper amount of memory for getMessage command"],[1,"function"],[0,".\r\n "]],"start1":870,"start2":870,"length1":12922,"length2":16}]],"length":12908,"saved":false}
{"ts":1352707509460,"patch":[[{"diffs":[[0,"eType >> 8);"],[1,"ma"],[0,"\r\n    messag"]],"start1":1465,"start2":1465,"length1":24,"length2":26}]],"length":12910,"saved":false}
{"ts":1352707515627,"patch":[[{"diffs":[[0,"e >> 8);"],[-1,"ma"],[0,"\r\n    me"]],"start1":1469,"start2":1469,"length1":18,"length2":16}]],"length":12908,"saved":false}
{"contributors":[],"silentsave":true,"ts":1352752202917,"patch":[[{"diffs":[[0,"  myMessage."],[-1,"messageC"],[1,"c"],[0,"ount = 0;\r\n "]],"start1":7255,"start2":7255,"length1":32,"length2":25}]],"length":12901,"saved":false}
{"ts":1352752206072,"patch":[[{"diffs":[[0,"  myMessage."],[-1,"messageI"],[1,"i"],[0,"ndex = 0;\r\n "]],"start1":7281,"start2":7281,"length1":32,"length2":25}]],"length":12894,"saved":false}
{"ts":1352752209083,"patch":[[{"diffs":[[0,"  myMessage."],[-1,"messageT"],[1,"t"],[0,"ype = MESSAG"]],"start1":7307,"start2":7307,"length1":32,"length2":25}]],"length":12887,"saved":false}
{"ts":1352752212271,"patch":[[{"diffs":[[0,"  myMessage."],[-1,"messageL"],[1,"l"],[0,"ength = 0;\r\n"]],"start1":7367,"start2":7367,"length1":32,"length2":25}]],"length":12880,"saved":false}
{"ts":1352752215134,"patch":[[{"diffs":[[0,"  myMessage."],[-1,"messageD"],[1,"d"],[0,"ata = buffer"]],"start1":7394,"start2":7394,"length1":32,"length2":25}]],"length":12873,"saved":false}
{"ts":1352752350422,"patch":[[{"diffs":[[0,"  myMessage."],[-1,"messageC"],[1,"c"],[0,"ount = 0;\r\n "]],"start1":7996,"start2":7996,"length1":32,"length2":25}]],"length":12866,"saved":false}
{"ts":1352752353507,"patch":[[{"diffs":[[0,"  myMessage."],[-1,"messageI"],[1,"i"],[0,"ndex = 0;\r\n "]],"start1":8022,"start2":8022,"length1":32,"length2":25}]],"length":12859,"saved":false}
{"ts":1352752356054,"patch":[[{"diffs":[[0,"  myMessage."],[-1,"messageT"],[1,"t"],[0,"ype = MESSAG"]],"start1":8048,"start2":8048,"length1":32,"length2":25}]],"length":12852,"saved":false}
{"ts":1352752360484,"patch":[[{"diffs":[[0,"  myMessage."],[-1,"messageL"],[1,"l"],[0,"ength = 0;\r\n"]],"start1":8106,"start2":8106,"length1":32,"length2":25}]],"length":12845,"saved":false}
{"ts":1352752364130,"patch":[[{"diffs":[[0,"  myMessage."],[-1,"messageD"],[1,"d"],[0,"ata = buffer"]],"start1":8133,"start2":8133,"length1":32,"length2":25}]],"length":12838,"saved":false}
{"contributors":[],"silentsave":true,"ts":1352857907738,"patch":[[{"diffs":[[0,"ngth, uint8 "],[-1,"r"],[1,"*"],[0,"fData[])\r\n{\r"]],"start1":184,"start2":184,"length1":25,"length2":25}]],"length":12838,"saved":false}
{"ts":1352857909213,"patch":[[{"diffs":[[0," uint8 *"],[1,"r"],[0,"fData[])"]],"start1":189,"start2":189,"length1":16,"length2":17}]],"length":12839,"saved":false}
{"ts":1352857911218,"patch":[[{"diffs":[[0,"Data"],[-1,"[]"],[0,")\r\n{"]],"start1":199,"start2":199,"length1":10,"length2":8}]],"length":12837,"saved":false}
