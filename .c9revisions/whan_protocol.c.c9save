{"ts":1352707256401,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"\r\n\r\n#include <whan_protocol.h>\r\n\r\n// This function is for interfacing with the UART interface\r\nvoid sendMessage(uint32 macHi, uint32 macLow, uint16 networkAddress, \r\n    uint8 rfDataLength, uint8 rfData[])\r\n{\r\n    \r\n    // TODO: fill in this function to tie it to the system UART\r\n    // It should implement the Zigbee Send Request command\r\n    \r\n}\r\n\r\n// Get message from the receive buffer and put it into the passed in variables\r\nvoid getMessage(uint32 *macHi, uint32 *macLow, uint16 *networkAddress,\r\n    uint8 *rfData)\r\n{\r\n    \r\n    // TODO: fill in this function to tie it to the system UART\r\n    // It should implement the Zigbee Receive Packet command\r\n    \r\n}\r\n\r\n// Get message length (the length of rfData)\r\nuint8 getMessageLength(void)\r\n{\r\n    \r\n    // TODO: fill in this function to allow host processor to allocate\r\n    // proper amount of memory for getMessage command.\r\n    \r\n}\r\n\r\n// This function is called by the top level functions, and integrates with the\r\n// lower level sendMessage() function\r\nvoid sendFormattedMessage(uint16 networkAddress, message myMessage)\r\n{\r\n    uint8 i = 0;\r\n    uint32 macLow = getMacLow(networkAddress);\r\n    uint32 macHigh = getMacHigh(networkAddress);\r\n    uint8 rfDataLength = myMessage.messageLength + 7;\r\n    uint8 messageBuffer[rfDataLength];\r\n    \r\n    messageBuffer[0] = myMessage.sourceLocale;\r\n    messageBuffer[1] = (uint8)(myMessage.sourceDeviceType);\r\n    messageBuffer[2] = (uint8)(myMessage.sourceDeviceType >> 8);\r\n    messageBuffer[3] = myMessage.messageCount;\r\n    messageBuffer[4] = myMessage.messageIndex;\r\n    messageBuffer[5] = myMessage.messageType;\r\n    messageBuffer[6] = myMessage.messageLength;\r\n    \r\n    for (i = 0; i < messageLength; i++) \r\n    {\r\n        messageBuffer[i+7] = myMessage.messageData[i];\r\n        \r\n    }\r\n    \r\n    sendMessage(macHigh, macLow, networkAddress, rfDataLength, messageBuffer);\r\n    \r\n}\r\n\r\n// Gets the message type, allowing for branching based on what was received\r\nuint8 getMessageType(uint8 *messageData)\r\n{\r\n    return messageData[5];\r\n    \r\n}\r\n\r\n// User Commands\r\nvoid sendUserCommandChangeValue(uint16 networkAddr, uint8 targetValueType, \r\n    uint32 targetValueData)\r\n{\r\n    message myMessage;\r\n    uint8 buffer[6];\r\n    \r\n    // Populate message fields\r\n    myMessage.sourceLocale = myLocale();\r\n    myMessage.deviceType = MY_DEVICE_TYPE;\r\n    myMessage.messageCount = 0;\r\n    myMessage.messageIndex = 0;\r\n    myMessage.messageType = MESSAGE_TYPE_USER_COMMAND;\r\n    myMessage.messageLength = 6;\r\n    myMessage.messageData = buffer;\r\n    \r\n    // Populate data buffer\r\n    buffer[0] = USER_COMMAND_CHANGE_VALUE;\r\n    buffer[1] = targetValueType;\r\n    buffer[2] = (uint8) ()targetValueData >> 24); // Big endian transmission\r\n    buffer[3] = (uint8) ()targetValueData >> 16);\r\n    buffer[4] = (uint8) ()targetValueData >> 8);\r\n    buffer[5] = (uint8) ()targetValueData >> 0);\r\n    \r\n    sendFormattedMessage(targetAddr, myMessage);\r\n    \r\n}\r\n    \r\nvoid sendUserCommandPromptAbilities(uint16 networkAddress)\r\n{\r\n    message myMessage;\r\n    uint8 buffer[1];\r\n    \r\n    // Populate message fields\r\n    myMessage.sourceLocale = myLocale();\r\n    myMessage.deviceType = MY_DEVICE_TYPE;\r\n    myMessage.messageCount = 0;\r\n    myMessage.messageIndex = 0;\r\n    myMessage.messageType = MESSAGE_TYPE_USER_COMMAND;\r\n    myMessage.messageLength = 1;\r\n    myMessage.messageData = buffer;\r\n    \r\n    buffer[0] = USER_COMMAND_PROMPT_ABILITIES;\r\n    \r\n    sendFormattedMessage(networkAddress, myMessage);\r\n    \r\n}\r\n\r\n\r\n// Notifications (general)\r\nvoid sendNotification(uint16 networkAddress, notification myNotification)\r\n{\r\n    message myMessage;\r\n    uint8 bufferLen = myNotification.numNotifications*5; // This will need to change for multiple messages...\r\n    uint8 i = 0;\r\n    uint8 buffer[bufferLen];\r\n    \r\n    // Populate message fields\r\n    myMessage.sourceLocale = myLocale();\r\n    myMessage.deviceType = MY_DEVICE_TYPE;\r\n    myMessage.messageCount = 0;//TODO: CALCULATE RQUIRED NUM OF MESSAGES!\r\n    myMessage.messageIndex = 0;\r\n    myMessage.messageType = MESSAGE_TYPE_NOTIFICATION;\r\n    myMessage.messageLength = bufferLen;\r\n    myMessage.messageData = buffer;\r\n    \r\n    buffer[0] = myNotification.numNotifications;\r\n    for (i = 0; i < myNotification.numNotifications; i++)\r\n    {\r\n        buffer[i*5+1] = (uint8) (myNotification.data[i] >> 24);\r\n        buffer[i*5+2] = (uint8) (myNotification.data[i] >> 16);\r\n        buffer[i*5+3] = (uint8) (myNotification.data[i] >> 8);\r\n        buffer[i*5+4] = (uint8) (myNotification.data[i] >> 0);\r\n        \r\n        buffer[i*5+1] = myNotification.type[i];\r\n        \r\n    }\r\n    \r\n    sendFormattedMessage(networkAddress, myMessage);\r\n    \r\n}\r\n\r\nvoid sendNotifications(uint8 numberOfDestinations, uint16 *networkAddresses, \r\n    notification myNotification)\r\n{\r\n    message myMessage;\r\n    uint8 bufferLen = myNotification.numNotifications*5; // This will need to change for multiple messages...\r\n    uint8 i = 0;\r\n    uint8 buffer[bufferLen];\r\n    \r\n    // Populate message fields\r\n    myMessage.sourceLocale = myLocale();\r\n    myMessage.deviceType = MY_DEVICE_TYPE;\r\n    myMessage.messageCount = 0;//TODO: CALCULATE RQUIRED NUM OF MESSAGES!\r\n    myMessage.messageIndex = 0;\r\n    myMessage.messageType = MESSAGE_TYPE_NOTIFICATION;\r\n    myMessage.messageLength = bufferLen;\r\n    myMessage.messageData = buffer;\r\n    \r\n    // Populate buffer\r\n    buffer[0] = myNotification.numNotifications;\r\n    for (i = 0; i < myNotification.numNotifications; i++)\r\n    {\r\n        buffer[i*5+1] = (uint8) (myNotification.data[i] >> 24);\r\n        buffer[i*5+2] = (uint8) (myNotification.data[i] >> 16);\r\n        buffer[i*5+3] = (uint8) (myNotification.data[i] >> 8);\r\n        buffer[i*5+4] = (uint8) (myNotification.data[i] >> 0);\r\n        \r\n        buffer[i*5+1] = myNotification.type[i];\r\n        \r\n    }\r\n    \r\n    for (i = 0; i < numberOfDestinations; i++)\r\n    {\r\n        sendFormattedMessage(networkAddresses[i], myMessage);\r\n        \r\n    }\r\n    \r\n}\r\n\r\n\r\n// Notification Request\r\nvoid sendNotificationRequest(uint16 networkAddress)\r\n{\r\n    message myMessage;\r\n    \r\n    // Populate message fields\r\n    myMessage.sourceLocale = myLocale();\r\n    myMessage.deviceType = MY_DEVICE_TYPE;\r\n    myMessage.messageCount = 0;\r\n    myMessage.messageIndex = 0;\r\n    myMessage.messageType = MESSAGE_TYPE_NOTIFICATION_REQUEST;\r\n    myMessage.messageLength = 0;\r\n    \r\n    sendFormattedMessage(networkAddress, myMessage);\r\n    \r\n}\r\n\r\n\r\n// Subscribe Request\r\nvoid sendSubscribeRequest(uint16 networkAddress)\r\n{\r\n    message myMessage;\r\n    \r\n    // Populate message fields\r\n    myMessage.sourceLocale = myLocale();\r\n    myMessage.deviceType = MY_DEVICE_TYPE;\r\n    myMessage.messageCount = 0;\r\n    myMessage.messageIndex = 0;\r\n    myMessage.messageType = MESSAGE_TYPE_SUBSCRIBE_REQUEST;\r\n    myMessage.messageLength = 0;\r\n    \r\n    sendFormattedMessage(networkAddress, myMessage);\r\n    \r\n}\r\n\r\n\r\n// Capability/Interest Notifications\r\nvoid sendCapabilitiesNotification(uint8 capabilitiesLength, \r\n    uint8 *capabilities)\r\n{\r\n    message myMessage;\r\n    uint8 buffer[capabilitiesLength];\r\n    uint8 i = 0;\r\n    \r\n    // Populate message fields\r\n    myMessage.sourceLocale = myLocale();\r\n    myMessage.deviceType = MY_DEVICE_TYPE;\r\n    myMessage.messageCount = 0;\r\n    myMessage.messageIndex = 0;\r\n    myMessage.messageType = MESSAGE_TYPE_CAPABILITY_NOTIFICATION;\r\n    myMessage.messageLength = 0;\r\n    myMessage.messageData = buffer;\r\n    \r\n    buffer[0] = capabilitiesLength;\r\n    for (i = 0; i < capabilitiesLength; i++)\r\n    {\r\n        buffer[i+1] = capabilities[i];\r\n        \r\n    }\r\n    \r\n    sendFormattedMessage(0, myMessage);\r\n    \r\n}\r\n\r\nvoid sendInterestsNotification(uint8 interestsLength, uint8 *interests,\r\n    uint8 *locales)\r\n{ // TODO: This will definitely need multi-spanning messages.\r\n    message myMessage;\r\n    uint8 buffer[2*interestsLength];\r\n    uint8 i = 0;\r\n    \r\n    // Populate message fields\r\n    myMessage.sourceLocale = myLocale();\r\n    myMessage.deviceType = MY_DEVICE_TYPE;\r\n    myMessage.messageCount = 0;\r\n    myMessage.messageIndex = 0;\r\n    myMessage.messageType = MESSAGE_TYPE_INTEREST_NOTIFICATION;\r\n    myMessage.messageLength = 0;\r\n    myMessage.messageData = buffer;\r\n    \r\n    buffer[0] = interestsLength;\r\n    for (i = 0; i < interestsLength; i++)\r\n    {\r\n        buffer[2*i+1] = interests[i];\r\n        buffer[2*i+2] = locales[i];\r\n    }\r\n    \r\n    sendFormattedMessage(0, myMessage);\r\n    \r\n}\r\n\r\n#IFDEF COORDINATOR\r\n// Subscribe Instruction\r\nvoid sendSubscribeInstruction(uint16 targetNetworkAddress, \r\n    uint16 networkAddress, uint32 macHi, uint32 macLow, uint8 locale, \r\n    uint8 numCapabilities, uint8 *capabilities)\r\n{\r\n    message myMessage;\r\n    uint8 buffer[12 + numCapabilites];\r\n    uint8 i = 0;\r\n    \r\n    // Populate message fields\r\n    myMessage.sourceLocale = myLocale();\r\n    myMessage.deviceType = MY_DEVICE_TYPE;\r\n    myMessage.messageCount = 0;\r\n    myMessage.messageIndex = 0;\r\n    myMessage.messageType = MESSAGE_TYPE_SUBSCRIBE_INSTRUCTION;\r\n    myMessage.messageLength = 12 + numCapabilities;\r\n    myMessage.messageData = buffer;\r\n    \r\n    buffer[0] = (uint8)(networkAddress >> 8);\r\n    buffer[1] = (uint8)(networkAddres);\r\n    buffer[2] = (uint8)(macHi >> 24);\r\n    buffer[3] = (uint8)(macHi >> 16);\r\n    buffer[4] = (uint8)(macHi >> 8);\r\n    buffer[5] = (uint8)(macHi >> 0);\r\n    buffer[6] = (uint8)(macLow >> 24);\r\n    buffer[7] = (uint8)(macLow >> 16);\r\n    buffer[8] = (uint8)(macLow >> 8);\r\n    buffer[9] = (uint8)(macLow >> 0);\r\n    buffer[10] = locale;\r\n    buffer[11] = numCapabilities;\r\n    for (i = 0; i < numCapabilities; i++)\r\n    {\r\n        buffer[i+12] = capabilities[i];\r\n    }\r\n    \r\n    sendFormattedMessage(targetNetworkAddress, myMessage);\r\n}\r\n\r\n#ENDIF\r\n\r\n// Safety Alarms\r\nvoid sendSafetyAlarm(uint8 riskType, uint8 riskLocale)\r\n{\r\n    // TODO: add something for possible universale risk locale? (0?)\r\n    message myMessage;\r\n    \r\n    getNodesInLocale(riskLocale, nodesInLocale);\r\n    \r\n    // Populate message fields\r\n    myMessage.sourceLocale = myLocale();\r\n    myMessage.deviceType = MY_DEVICE_TYPE;\r\n    myMessage.messageCount = 0;\r\n    myMessage.messageIndex = 0;\r\n    myMessage.messageType = MESSAGE_TYPE_SAFETY_ALARM;\r\n    myMessage.messageLength = 0;\r\n    \r\n    for (i = 0; i < MY_ADDRESS_BOOK_LENGTH; i++)\r\n    {\r\n        if (addressBook[i].locale == riskLocale)\r\n        {\r\n            sendFormattedMessage(addressBook[i].networkAddress, myMessage);\r\n            \r\n        }\r\n        \r\n    }\r\n    \r\n    // Send safety alert to coordinator for good measure\r\n    sendFormattedMessage(0, myMessage);\r\n    \r\n}\r\n\r\n// Scans the address book for nodes that are interested in data contained in the\r\n// passed in notification and sends data to these nodes.  Returns the number of\r\n// nodes notified.\r\nuint8 notifyInterestedNodes(notification myNotification)\r\n{\r\n    uint8 i = 0, j = 0, k = 0, numNotified = 0;\r\n    notification N;\r\n    int32 data[myNotification.numNotifications];\r\n    int8 types[myNotification.numNotifications];\r\n    N.data = data;\r\n    N.types = types;\r\n    \r\n    for (i = 0; i < MY_ADDRESS_BOOK_LENGTH; i++)\r\n    {\r\n        if (addressBook[i].locale != 0)\r\n        {\r\n            // For each entry in the address book, construct a notification \r\n            // containing data that entry is interested in\r\n            N.numNotifications = 0;\r\n            \r\n            for (j = 0; j < myNotification.numNotifications; j++)\r\n            {\r\n                // For each notification in the passed in notification, check\r\n                // if this entry is interested in it\r\n                \r\n                for (k = 0; k < addressBook[i].numInterests; k++)\r\n                {\r\n                    // For each interest in this entry, check if the passed in \r\n                    // notification is equal to it\r\n                    \r\n                    if (addressBook[i].interests[k] == myNotification.types[j])\r\n                    {\r\n                        // If entry is interested, add this data to the notification\r\n                        N.data[N.numNotifications] = myNotification.data[j];\r\n                        N.types[N.numNotifications] = myNotification.types[j];\r\n                        N.numNotifications += 1;\r\n                        \r\n                        // Exit k for loop (this data type has been handled)\r\n                        break;\r\n                        \r\n                    }\r\n                    \r\n                }\r\n                \r\n            }\r\n            \r\n        }\r\n        \r\n        // Check if this entry is interested in anything from the notification\r\n        if (N.numNotifications > 0)\r\n        {\r\n            // Send constructed notification\r\n            sendNotificaiton(addressBook[i].networkAddress, N);\r\n            numNotified += 1;\r\n            \r\n        }\r\n        \r\n    }\r\n    \r\n    return numNotified;\r\n    \r\n}"]],"start1":0,"start2":0,"length1":0,"length2":12907}]],"length":12907}
{"contributors":[],"silentsave":false,"ts":1352707256340,"patch":[[{"diffs":[[1,"\r\n\r\n#include <whan_protocol.h>\r\n\r\n// This function is for interfacing with the UART interface\r\nvoid sendMessage(uint32 macHi, uint32 macLow, uint16 networkAddress, \r\n    uint8 rfDataLength, uint8 rfData[])\r\n{\r\n    \r\n    // TODO: fill in this function to tie it to the system UART\r\n    // It should implement the Zigbee Send Request command\r\n    \r\n}\r\n\r\n// Get message from the receive buffer and put it into the passed in variables\r\nvoid getMessage(uint32 *macHi, uint32 *macLow, uint16 *networkAddress,\r\n    uint8 *rfData)\r\n{\r\n    \r\n    // TODO: fill in this function to tie it to the system UART\r\n    // It should implement the Zigbee Receive Packet command\r\n    \r\n}\r\n\r\n// Get message length (the length of rfData)\r\nuint8 getMessageLength(void)\r\n{\r\n    \r\n    // TODO: fill in this function to allow host processor to allocate\r\n    // proper amount of memory for getMessage command.\r\n    \r\n}\r\n\r\n// This function is called by the top level functions, and integrates with the\r\n// lower level sendMessage() function\r\nvoid sendFormattedMessage(uint16 networkAddress, message myMessage)\r\n{\r\n    uint8 i = 0;\r\n    uint32 macLow = getMacLow(networkAddress);\r\n    uint32 macHigh = getMacHigh(networkAddress);\r\n    uint8 rfDataLength = myMessage.messageLength + 7;\r\n    uint8 messageBuffer[rfDataLength];\r\n    \r\n    messageBuffer[0] = myMessage.sourceLocale;\r\n    messageBuffer[1] = (uint8)(myMessage.sourceDeviceType);\r\n    messageBuffer[2] = (uint8)(myMessage.sourceDeviceType >> 8);\r\n    messageBuffer[3] = myMessage.messageCount;\r\n    messageBuffer[4] = myMessage.messageIndex;\r\n    messageBuffer[5] = myMessage.messageType;\r\n    messageBuffer[6] = myMessage.messageLength;\r\n    \r\n    for (i = 0; i < messageLength; i++) \r\n    {\r\n        messageBuffer[i+7] = myMessage.messageData[i];\r\n        \r\n    }\r\n    \r\n    sendMessage(macHigh, macLow, networkAddress, rfDataLength, messageBuffer);\r\n    \r\n}\r\n\r\n// Gets the message type, allowing for branching based on what was received\r\nuint8 getMessageType(uint8 *messageData)\r\n{\r\n    return messageData[5];\r\n    \r\n}\r\n\r\n// User Commands\r\nvoid sendUserCommandChangeValue(uint16 networkAddr, uint8 targetValueType, \r\n    uint32 targetValueData)\r\n{\r\n    message myMessage;\r\n    uint8 buffer[6];\r\n    \r\n    // Populate message fields\r\n    myMessage.sourceLocale = myLocale();\r\n    myMessage.deviceType = MY_DEVICE_TYPE;\r\n    myMessage.messageCount = 0;\r\n    myMessage.messageIndex = 0;\r\n    myMessage.messageType = MESSAGE_TYPE_USER_COMMAND;\r\n    myMessage.messageLength = 6;\r\n    myMessage.messageData = buffer;\r\n    \r\n    // Populate data buffer\r\n    buffer[0] = USER_COMMAND_CHANGE_VALUE;\r\n    buffer[1] = targetValueType;\r\n    buffer[2] = (uint8) ()targetValueData >> 24); // Big endian transmission\r\n    buffer[3] = (uint8) ()targetValueData >> 16);\r\n    buffer[4] = (uint8) ()targetValueData >> 8);\r\n    buffer[5] = (uint8) ()targetValueData >> 0);\r\n    \r\n    sendFormattedMessage(targetAddr, myMessage);\r\n    \r\n}\r\n    \r\nvoid sendUserCommandPromptAbilities(uint16 networkAddress)\r\n{\r\n    message myMessage;\r\n    uint8 buffer[1];\r\n    \r\n    // Populate message fields\r\n    myMessage.sourceLocale = myLocale();\r\n    myMessage.deviceType = MY_DEVICE_TYPE;\r\n    myMessage.messageCount = 0;\r\n    myMessage.messageIndex = 0;\r\n    myMessage.messageType = MESSAGE_TYPE_USER_COMMAND;\r\n    myMessage.messageLength = 1;\r\n    myMessage.messageData = buffer;\r\n    \r\n    buffer[0] = USER_COMMAND_PROMPT_ABILITIES;\r\n    \r\n    sendFormattedMessage(networkAddress, myMessage);\r\n    \r\n}\r\n\r\n\r\n// Notifications (general)\r\nvoid sendNotification(uint16 networkAddress, notification myNotification)\r\n{\r\n    message myMessage;\r\n    uint8 bufferLen = myNotification.numNotifications*5; // This will need to change for multiple messages...\r\n    uint8 i = 0;\r\n    uint8 buffer[bufferLen];\r\n    \r\n    // Populate message fields\r\n    myMessage.sourceLocale = myLocale();\r\n    myMessage.deviceType = MY_DEVICE_TYPE;\r\n    myMessage.messageCount = 0;//TODO: CALCULATE RQUIRED NUM OF MESSAGES!\r\n    myMessage.messageIndex = 0;\r\n    myMessage.messageType = MESSAGE_TYPE_NOTIFICATION;\r\n    myMessage.messageLength = bufferLen;\r\n    myMessage.messageData = buffer;\r\n    \r\n    buffer[0] = myNotification.numNotifications;\r\n    for (i = 0; i < myNotification.numNotifications; i++)\r\n    {\r\n        buffer[i*5+1] = (uint8) (myNotification.data[i] >> 24);\r\n        buffer[i*5+2] = (uint8) (myNotification.data[i] >> 16);\r\n        buffer[i*5+3] = (uint8) (myNotification.data[i] >> 8);\r\n        buffer[i*5+4] = (uint8) (myNotification.data[i] >> 0);\r\n        \r\n        buffer[i*5+1] = myNotification.type[i];\r\n        \r\n    }\r\n    \r\n    sendFormattedMessage(networkAddress, myMessage);\r\n    \r\n}\r\n\r\nvoid sendNotifications(uint8 numberOfDestinations, uint16 *networkAddresses, \r\n    notification myNotification)\r\n{\r\n    message myMessage;\r\n    uint8 bufferLen = myNotification.numNotifications*5; // This will need to change for multiple messages...\r\n    uint8 i = 0;\r\n    uint8 buffer[bufferLen];\r\n    \r\n    // Populate message fields\r\n    myMessage.sourceLocale = myLocale();\r\n    myMessage.deviceType = MY_DEVICE_TYPE;\r\n    myMessage.messageCount = 0;//TODO: CALCULATE RQUIRED NUM OF MESSAGES!\r\n    myMessage.messageIndex = 0;\r\n    myMessage.messageType = MESSAGE_TYPE_NOTIFICATION;\r\n    myMessage.messageLength = bufferLen;\r\n    myMessage.messageData = buffer;\r\n    \r\n    // Populate buffer\r\n    buffer[0] = myNotification.numNotifications;\r\n    for (i = 0; i < myNotification.numNotifications; i++)\r\n    {\r\n        buffer[i*5+1] = (uint8) (myNotification.data[i] >> 24);\r\n        buffer[i*5+2] = (uint8) (myNotification.data[i] >> 16);\r\n        buffer[i*5+3] = (uint8) (myNotification.data[i] >> 8);\r\n        buffer[i*5+4] = (uint8) (myNotification.data[i] >> 0);\r\n        \r\n        buffer[i*5+1] = myNotification.type[i];\r\n        \r\n    }\r\n    \r\n    for (i = 0; i < numberOfDestinations; i++)\r\n    {\r\n        sendFormattedMessage(networkAddresses[i], myMessage);\r\n        \r\n    }\r\n    \r\n}\r\n\r\n\r\n// Notification Request\r\nvoid sendNotificationRequest(uint16 networkAddress)\r\n{\r\n    message myMessage;\r\n    \r\n    // Populate message fields\r\n    myMessage.sourceLocale = myLocale();\r\n    myMessage.deviceType = MY_DEVICE_TYPE;\r\n    myMessage.messageCount = 0;\r\n    myMessage.messageIndex = 0;\r\n    myMessage.messageType = MESSAGE_TYPE_NOTIFICATION_REQUEST;\r\n    myMessage.messageLength = 0;\r\n    \r\n    sendFormattedMessage(networkAddress, myMessage);\r\n    \r\n}\r\n\r\n\r\n// Subscribe Request\r\nvoid sendSubscribeRequest(uint16 networkAddress)\r\n{\r\n    message myMessage;\r\n    \r\n    // Populate message fields\r\n    myMessage.sourceLocale = myLocale();\r\n    myMessage.deviceType = MY_DEVICE_TYPE;\r\n    myMessage.messageCount = 0;\r\n    myMessage.messageIndex = 0;\r\n    myMessage.messageType = MESSAGE_TYPE_SUBSCRIBE_REQUEST;\r\n    myMessage.messageLength = 0;\r\n    \r\n    sendFormattedMessage(networkAddress, myMessage);\r\n    \r\n}\r\n\r\n\r\n// Capability/Interest Notifications\r\nvoid sendCapabilitiesNotification(uint8 capabilitiesLength, \r\n    uint8 *capabilities)\r\n{\r\n    message myMessage;\r\n    uint8 buffer[capabilitiesLength];\r\n    uint8 i = 0;\r\n    \r\n    // Populate message fields\r\n    myMessage.sourceLocale = myLocale();\r\n    myMessage.deviceType = MY_DEVICE_TYPE;\r\n    myMessage.messageCount = 0;\r\n    myMessage.messageIndex = 0;\r\n    myMessage.messageType = MESSAGE_TYPE_CAPABILITY_NOTIFICATION;\r\n    myMessage.messageLength = 0;\r\n    myMessage.messageData = buffer;\r\n    \r\n    buffer[0] = capabilitiesLength;\r\n    for (i = 0; i < capabilitiesLength; i++)\r\n    {\r\n        buffer[i+1] = capabilities[i];\r\n        \r\n    }\r\n    \r\n    sendFormattedMessage(0, myMessage);\r\n    \r\n}\r\n\r\nvoid sendInterestsNotification(uint8 interestsLength, uint8 *interests,\r\n    uint8 *locales)\r\n{ // TODO: This will definitely need multi-spanning messages.\r\n    message myMessage;\r\n    uint8 buffer[2*interestsLength];\r\n    uint8 i = 0;\r\n    \r\n    // Populate message fields\r\n    myMessage.sourceLocale = myLocale();\r\n    myMessage.deviceType = MY_DEVICE_TYPE;\r\n    myMessage.messageCount = 0;\r\n    myMessage.messageIndex = 0;\r\n    myMessage.messageType = MESSAGE_TYPE_INTEREST_NOTIFICATION;\r\n    myMessage.messageLength = 0;\r\n    myMessage.messageData = buffer;\r\n    \r\n    buffer[0] = interestsLength;\r\n    for (i = 0; i < interestsLength; i++)\r\n    {\r\n        buffer[2*i+1] = interests[i];\r\n        buffer[2*i+2] = locales[i];\r\n    }\r\n    \r\n    sendFormattedMessage(0, myMessage);\r\n    \r\n}\r\n\r\n#IFDEF COORDINATOR\r\n// Subscribe Instruction\r\nvoid sendSubscribeInstruction(uint16 targetNetworkAddress, \r\n    uint16 networkAddress, uint32 macHi, uint32 macLow, uint8 locale, \r\n    uint8 numCapabilities, uint8 *capabilities)\r\n{\r\n    message myMessage;\r\n    uint8 buffer[12 + numCapabilites];\r\n    uint8 i = 0;\r\n    \r\n    // Populate message fields\r\n    myMessage.sourceLocale = myLocale();\r\n    myMessage.deviceType = MY_DEVICE_TYPE;\r\n    myMessage.messageCount = 0;\r\n    myMessage.messageIndex = 0;\r\n    myMessage.messageType = MESSAGE_TYPE_SUBSCRIBE_INSTRUCTION;\r\n    myMessage.messageLength = 12 + numCapabilities;\r\n    myMessage.messageData = buffer;\r\n    \r\n    buffer[0] = (uint8)(networkAddress >> 8);\r\n    buffer[1] = (uint8)(networkAddres);\r\n    buffer[2] = (uint8)(macHi >> 24);\r\n    buffer[3] = (uint8)(macHi >> 16);\r\n    buffer[4] = (uint8)(macHi >> 8);\r\n    buffer[5] = (uint8)(macHi >> 0);\r\n    buffer[6] = (uint8)(macLow >> 24);\r\n    buffer[7] = (uint8)(macLow >> 16);\r\n    buffer[8] = (uint8)(macLow >> 8);\r\n    buffer[9] = (uint8)(macLow >> 0);\r\n    buffer[10] = locale;\r\n    buffer[11] = numCapabilities;\r\n    for (i = 0; i < numCapabilities; i++)\r\n    {\r\n        buffer[i+12] = capabilities[i];\r\n    }\r\n    \r\n    sendFormattedMessage(targetNetworkAddress, myMessage);\r\n}\r\n\r\n#ENDIF\r\n\r\n// Safety Alarms\r\nvoid sendSafetyAlarm(uint8 riskType, uint8 riskLocale)\r\n{\r\n    // TODO: add something for possible universale risk locale? (0?)\r\n    message myMessage;\r\n    \r\n    getNodesInLocale(riskLocale, nodesInLocale);\r\n    \r\n    // Populate message fields\r\n    myMessage.sourceLocale = myLocale();\r\n    myMessage.deviceType = MY_DEVICE_TYPE;\r\n    myMessage.messageCount = 0;\r\n    myMessage.messageIndex = 0;\r\n    myMessage.messageType = MESSAGE_TYPE_SAFETY_ALARM;\r\n    myMessage.messageLength = 0;\r\n    \r\n    for (i = 0; i < MY_ADDRESS_BOOK_LENGTH; i++)\r\n    {\r\n        if (addressBook[i].locale == riskLocale)\r\n        {\r\n            sendFormattedMessage(addressBook[i].networkAddress, myMessage);\r\n            \r\n        }\r\n        \r\n    }\r\n    \r\n    // Send safety alert to coordinator for good measure\r\n    sendFormattedMessage(0, myMessage);\r\n    \r\n}\r\n\r\n// Scans the address book for nodes that are interested in data contained in the\r\n// passed in notification and sends data to these nodes.  Returns the number of\r\n// nodes notified.\r\nuint8 notifyInterestedNodes(notification myNotification)\r\n{\r\n    uint8 i = 0, j = 0, k = 0, numNotified = 0;\r\n    notification N;\r\n    int32 data[myNotification.numNotifications];\r\n    int8 types[myNotification.numNotifications];\r\n    N.data = data;\r\n    N.types = types;\r\n    \r\n    for (i = 0; i < MY_ADDRESS_BOOK_LENGTH; i++)\r\n    {\r\n        if (addressBook[i].locale != 0)\r\n        {\r\n            // For each entry in the address book, construct a notification \r\n            // containing data that entry is interested in\r\n            N.numNotifications = 0;\r\n            \r\n            for (j = 0; j < myNotification.numNotifications; j++)\r\n            {\r\n                // For each notification in the passed in notification, check\r\n                // if this entry is interested in it\r\n                \r\n                for (k = 0; k < addressBook[i].numInterests; k++)\r\n                {\r\n                    // For each interest in this entry, check if the passed in \r\n                    // notification is equal to it\r\n                    \r\n                    if (addressBook[i].interests[k] == myNotification.types[j])\r\n                    {\r\n                        // If entry is interested, add this data to the notification\r\n                        N.data[N.numNotifications] = myNotification.data[j];\r\n                        N.types[N.numNotifications] = myNotification.types[j];\r\n                        N.numNotifications += 1;\r\n                        \r\n                        // Exit k for loop (this data type has been handled)\r\n                        break;\r\n                        \r\n                    }\r\n                    \r\n                }\r\n                \r\n            }\r\n            \r\n        }\r\n        \r\n        // Check if this entry is interested in anything from the notification\r\n        if (N.numNotifications > 0)\r\n        {\r\n            // Send constructed notification\r\n            sendNotificaiton(addressBook[i].networkAddress, N);\r\n            numNotified += 1;\r\n            \r\n        }\r\n        \r\n    }\r\n    \r\n    return numNotified;\r\n    \r\n}"]],"start1":0,"start2":0,"length1":0,"length2":12907}]],"length":12907,"saved":false}
{"contributors":[],"silentsave":true,"ts":1352707341547,"patch":[[{"diffs":[[0,"age "],[-1,"command.\r\n    \r\n}\r\n\r\n// This function is called by the top level functions, and integrates with the\r\n// lower level sendMessage() function\r\nvoid sendFormattedMessage(uint16 networkAddress, message myMessage)\r\n{\r\n    uint8 i = 0;\r\n    uint32 macLow = getMacLow(networkAddress);\r\n    uint32 macHigh = getMacHigh(networkAddress);\r\n    uint8 rfDataLength = myMessage.messageLength + 7;\r\n    uint8 messageBuffer[rfDataLength];\r\n    \r\n    messageBuffer[0] = myMessage.sourceLocale;\r\n    messageBuffer[1] = (uint8)(myMessage.sourceDeviceType);\r\n    messageBuffer[2] = (uint8)(myMessage.sourceDeviceType >> 8);\r\n    messageBuffer[3] = myMessage.messageCount;\r\n    messageBuffer[4] = myMessage.messageIndex;\r\n    messageBuffer[5] = myMessage.messageType;\r\n    messageBuffer[6] = myMessage.messageLength;\r\n    \r\n    for (i = 0; i < messageLength; i++) \r\n    {\r\n        messageBuffer[i+7] = myMessage.messageData[i];\r\n        \r\n    }\r\n    \r\n    sendMessage(macHigh, macLow, networkAddress, rfDataLength, messageBuffer);\r\n    \r\n}\r\n\r\n// Gets the message type, allowing for branching based on what was received\r\nuint8 getMessageType(uint8 *messageData)\r\n{\r\n    return messageData[5];\r\n    \r\n}\r\n\r\n// User Commands\r\nvoid sendUserCommandChangeValue(uint16 networkAddr, uint8 targetValueType, \r\n    uint32 targetValueData)\r\n{\r\n    message myMessage;\r\n    uint8 buffer[6];\r\n    \r\n    // Populate message fields\r\n    myMessage.sourceLocale = myLocale();\r\n    myMessage.deviceType = MY_DEVICE_TYPE;\r\n    myMessage.messageCount = 0;\r\n    myMessage.messageIndex = 0;\r\n    myMessage.messageType = MESSAGE_TYPE_USER_COMMAND;\r\n    myMessage.messageLength = 6;\r\n    myMessage.messageData = buffer;\r\n    \r\n    // Populate data buffer\r\n    buffer[0] = USER_COMMAND_CHANGE_VALUE;\r\n    buffer[1] = targetValueType;\r\n    buffer[2] = (uint8) ()targetValueData >> 24); // Big endian transmission\r\n    buffer[3] = (uint8) ()targetValueData >> 16);\r\n    buffer[4] = (uint8) ()targetValueData >> 8);\r\n    buffer[5] = (uint8) ()targetValueData >> 0);\r\n    \r\n    sendFormattedMessage(targetAddr, myMessage);\r\n    \r\n}\r\n    \r\nvoid sendUserCommandPromptAbilities(uint16 networkAddress)\r\n{\r\n    message myMessage;\r\n    uint8 buffer[1];\r\n    \r\n    // Populate message fields\r\n    myMessage.sourceLocale = myLocale();\r\n    myMessage.deviceType = MY_DEVICE_TYPE;\r\n    myMessage.messageCount = 0;\r\n    myMessage.messageIndex = 0;\r\n    myMessage.messageType = MESSAGE_TYPE_USER_COMMAND;\r\n    myMessage.messageLength = 1;\r\n    myMessage.messageData = buffer;\r\n    \r\n    buffer[0] = USER_COMMAND_PROMPT_ABILITIES;\r\n    \r\n    sendFormattedMessage(networkAddress, myMessage);\r\n    \r\n}\r\n\r\n\r\n// Notifications (general)\r\nvoid sendNotification(uint16 networkAddress, notification myNotification)\r\n{\r\n    message myMessage;\r\n    uint8 bufferLen = myNotification.numNotifications*5; // This will need to change for multiple messages...\r\n    uint8 i = 0;\r\n    uint8 buffer[bufferLen];\r\n    \r\n    // Populate message fields\r\n    myMessage.sourceLocale = myLocale();\r\n    myMessage.deviceType = MY_DEVICE_TYPE;\r\n    myMessage.messageCount = 0;//TODO: CALCULATE RQUIRED NUM OF MESSAGES!\r\n    myMessage.messageIndex = 0;\r\n    myMessage.messageType = MESSAGE_TYPE_NOTIFICATION;\r\n    myMessage.messageLength = bufferLen;\r\n    myMessage.messageData = buffer;\r\n    \r\n    buffer[0] = myNotification.numNotifications;\r\n    for (i = 0; i < myNotification.numNotifications; i++)\r\n    {\r\n        buffer[i*5+1] = (uint8) (myNotification.data[i] >> 24);\r\n        buffer[i*5+2] = (uint8) (myNotification.data[i] >> 16);\r\n        buffer[i*5+3] = (uint8) (myNotification.data[i] >> 8);\r\n        buffer[i*5+4] = (uint8) (myNotification.data[i] >> 0);\r\n        \r\n        buffer[i*5+1] = myNotification.type[i];\r\n        \r\n    }\r\n    \r\n    sendFormattedMessage(networkAddress, myMessage);\r\n    \r\n}\r\n\r\nvoid sendNotifications(uint8 numberOfDestinations, uint16 *networkAddresses, \r\n    notification myNotification)\r\n{\r\n    message myMessage;\r\n    uint8 bufferLen = myNotification.numNotifications*5; // This will need to change for multiple messages...\r\n    uint8 i = 0;\r\n    uint8 buffer[bufferLen];\r\n    \r\n    // Populate message fields\r\n    myMessage.sourceLocale = myLocale();\r\n    myMessage.deviceType = MY_DEVICE_TYPE;\r\n    myMessage.messageCount = 0;//TODO: CALCULATE RQUIRED NUM OF MESSAGES!\r\n    myMessage.messageIndex = 0;\r\n    myMessage.messageType = MESSAGE_TYPE_NOTIFICATION;\r\n    myMessage.messageLength = bufferLen;\r\n    myMessage.messageData = buffer;\r\n    \r\n    // Populate buffer\r\n    buffer[0] = myNotification.numNotifications;\r\n    for (i = 0; i < myNotification.numNotifications; i++)\r\n    {\r\n        buffer[i*5+1] = (uint8) (myNotification.data[i] >> 24);\r\n        buffer[i*5+2] = (uint8) (myNotification.data[i] >> 16);\r\n        buffer[i*5+3] = (uint8) (myNotification.data[i] >> 8);\r\n        buffer[i*5+4] = (uint8) (myNotification.data[i] >> 0);\r\n        \r\n        buffer[i*5+1] = myNotification.type[i];\r\n        \r\n    }\r\n    \r\n    for (i = 0; i < numberOfDestinations; i++)\r\n    {\r\n        sendFormattedMessage(networkAddresses[i], myMessage);\r\n        \r\n    }\r\n    \r\n}\r\n\r\n\r\n// Notification Request\r\nvoid sendNotificationRequest(uint16 networkAddress)\r\n{\r\n    message myMessage;\r\n    \r\n    // Populate message fields\r\n    myMessage.sourceLocale = myLocale();\r\n    myMessage.deviceType = MY_DEVICE_TYPE;\r\n    myMessage.messageCount = 0;\r\n    myMessage.messageIndex = 0;\r\n    myMessage.messageType = MESSAGE_TYPE_NOTIFICATION_REQUEST;\r\n    myMessage.messageLength = 0;\r\n    \r\n    sendFormattedMessage(networkAddress, myMessage);\r\n    \r\n}\r\n\r\n\r\n// Subscribe Request\r\nvoid sendSubscribeRequest(uint16 networkAddress)\r\n{\r\n    message myMessage;\r\n    \r\n    // Populate message fields\r\n    myMessage.sourceLocale = myLocale();\r\n    myMessage.deviceType = MY_DEVICE_TYPE;\r\n    myMessage.messageCount = 0;\r\n    myMessage.messageIndex = 0;\r\n    myMessage.messageType = MESSAGE_TYPE_SUBSCRIBE_REQUEST;\r\n    myMessage.messageLength = 0;\r\n    \r\n    sendFormattedMessage(networkAddress, myMessage);\r\n    \r\n}\r\n\r\n\r\n// Capability/Interest Notifications\r\nvoid sendCapabilitiesNotification(uint8 capabilitiesLength, \r\n    uint8 *capabilities)\r\n{\r\n    message myMessage;\r\n    uint8 buffer[capabilitiesLength];\r\n    uint8 i = 0;\r\n    \r\n    // Populate message fields\r\n    myMessage.sourceLocale = myLocale();\r\n    myMessage.deviceType = MY_DEVICE_TYPE;\r\n    myMessage.messageCount = 0;\r\n    myMessage.messageIndex = 0;\r\n    myMessage.messageType = MESSAGE_TYPE_CAPABILITY_NOTIFICATION;\r\n    myMessage.messageLength = 0;\r\n    myMessage.messageData = buffer;\r\n    \r\n    buffer[0] = capabilitiesLength;\r\n    for (i = 0; i < capabilitiesLength; i++)\r\n    {\r\n        buffer[i+1] = capabilities[i];\r\n        \r\n    }\r\n    \r\n    sendFormattedMessage(0, myMessage);\r\n    \r\n}\r\n\r\nvoid sendInterestsNotification(uint8 interestsLength, uint8 *interests,\r\n    uint8 *locales)\r\n{ // TODO: This will definitely need multi-spanning messages.\r\n    message myMessage;\r\n    uint8 buffer[2*interestsLength];\r\n    uint8 i = 0;\r\n    \r\n    // Populate message fields\r\n    myMessage.sourceLocale = myLocale();\r\n    myMessage.deviceType = MY_DEVICE_TYPE;\r\n    myMessage.messageCount = 0;\r\n    myMessage.messageIndex = 0;\r\n    myMessage.messageType = MESSAGE_TYPE_INTEREST_NOTIFICATION;\r\n    myMessage.messageLength = 0;\r\n    myMessage.messageData = buffer;\r\n    \r\n    buffer[0] = interestsLength;\r\n    for (i = 0; i < interestsLength; i++)\r\n    {\r\n        buffer[2*i+1] = interests[i];\r\n        buffer[2*i+2] = locales[i];\r\n    }\r\n    \r\n    sendFormattedMessage(0, myMessage);\r\n    \r\n}\r\n\r\n#IFDEF COORDINATOR\r\n// Subscribe Instruction\r\nvoid sendSubscribeInstruction(uint16 targetNetworkAddress, \r\n    uint16 networkAddress, uint32 macHi, uint32 macLow, uint8 locale, \r\n    uint8 numCapabilities, uint8 *capabilities)\r\n{\r\n    message myMessage;\r\n    uint8 buffer[12 + numCapabilites];\r\n    uint8 i = 0;\r\n    \r\n    // Populate message fields\r\n    myMessage.sourceLocale = myLocale();\r\n    myMessage.deviceType = MY_DEVICE_TYPE;\r\n    myMessage.messageCount = 0;\r\n    myMessage.messageIndex = 0;\r\n    myMessage.messageType = MESSAGE_TYPE_SUBSCRIBE_INSTRUCTION;\r\n    myMessage.messageLength = 12 + numCapabilities;\r\n    myMessage.messageData = buffer;\r\n    \r\n    buffer[0] = (uint8)(networkAddress >> 8);\r\n    buffer[1] = (uint8)(networkAddres);\r\n    buffer[2] = (uint8)(macHi >> 24);\r\n    buffer[3] = (uint8)(macHi >> 16);\r\n    buffer[4] = (uint8)(macHi >> 8);\r\n    buffer[5] = (uint8)(macHi >> 0);\r\n    buffer[6] = (uint8)(macLow >> 24);\r\n    buffer[7] = (uint8)(macLow >> 16);\r\n    buffer[8] = (uint8)(macLow >> 8);\r\n    buffer[9] = (uint8)(macLow >> 0);\r\n    buffer[10] = locale;\r\n    buffer[11] = numCapabilities;\r\n    for (i = 0; i < numCapabilities; i++)\r\n    {\r\n        buffer[i+12] = capabilities[i];\r\n    }\r\n    \r\n    sendFormattedMessage(targetNetworkAddress, myMessage);\r\n}\r\n\r\n#ENDIF\r\n\r\n// Safety Alarms\r\nvoid sendSafetyAlarm(uint8 riskType, uint8 riskLocale)\r\n{\r\n    // TODO: add something for possible universale risk locale? (0?)\r\n    message myMessage;\r\n    \r\n    getNodesInLocale(riskLocale, nodesInLocale);\r\n    \r\n    // Populate message fields\r\n    myMessage.sourceLocale = myLocale();\r\n    myMessage.deviceType = MY_DEVICE_TYPE;\r\n    myMessage.messageCount = 0;\r\n    myMessage.messageIndex = 0;\r\n    myMessage.messageType = MESSAGE_TYPE_SAFETY_ALARM;\r\n    myMessage.messageLength = 0;\r\n    \r\n    for (i = 0; i < MY_ADDRESS_BOOK_LENGTH; i++)\r\n    {\r\n        if (addressBook[i].locale == riskLocale)\r\n        {\r\n            sendFormattedMessage(addressBook[i].networkAddress, myMessage);\r\n            \r\n        }\r\n        \r\n    }\r\n    \r\n    // Send safety alert to coordinator for good measure\r\n    sendFormattedMessage(0, myMessage);\r\n    \r\n}\r\n\r\n// Scans the address book for nodes that are interested in data contained in the\r\n// passed in notification and sends data to these nodes.  Returns the number of\r\n// nodes notified.\r\nuint8 notifyInterestedNodes(notification myNotification)\r\n{\r\n    uint8 i = 0, j = 0, k = 0, numNotified = 0;\r\n    notification N;\r\n    int32 data[myNotification.numNotifications];\r\n    int8 types[myNotification.numNotifications];\r\n    N.data = data;\r\n    N.types = types;\r\n    \r\n    for (i = 0; i < MY_ADDRESS_BOOK_LENGTH; i++)\r\n    {\r\n        if (addressBook[i].locale != 0)\r\n        {\r\n            // For each entry in the address book, construct a notification \r\n            // containing data that entry is interested in\r\n            N.numNotifications = 0;\r\n            \r\n            for (j = 0; j < myNotification.numNotifications; j++)\r\n            {\r\n                // For each notification in the passed in notification, check\r\n                // if this entry is interested in it\r\n                \r\n                for (k = 0; k < addressBook[i].numInterests; k++)\r\n                {\r\n                    // For each interest in this entry, check if the passed in \r\n                    // notification is equal to it\r\n                    \r\n                    if (addressBook[i].interests[k] == myNotification.types[j])\r\n                    {\r\n                        // If entry is interested, add this data to the notification\r\n                        N.data[N.numNotifications] = myNotification.data[j];\r\n                        N.types[N.numNotifications] = myNotification.types[j];\r\n                        N.numNotifications += 1;\r\n                        \r\n                        // Exit k for loop (this data type has been handled)\r\n                        break;\r\n                        \r\n                    }\r\n                    \r\n                }\r\n                \r\n            }\r\n            \r\n        }\r\n        \r\n        // Check if this entry is interested in anything from the notification\r\n        if (N.numNotifications > 0)\r\n        {\r\n            // Send constructed notification\r\n            sendNotificaiton(addressBook[i].networkAddress, N);\r\n            numNotified += 1;\r\n            \r\n        }\r\n        \r\n    }\r\n    \r\n    return numNotified;\r\n    \r\n}\r\n\r\n#include <whan_protocol.h>\r\n\r\n// This function is for interfacing with the UART interface\r\nvoid sendMessage(uint32 macHi, uint32 macLow, uint16 networkAddress, \r\n    uint8 rfDataLength, uint8 rfData[])\r\n{\r\n    \r\n    // TODO: fill in this function to tie it to the system UART\r\n    // It should implement the Zigbee Send Request command\r\n    \r\n}\r\n\r\n// Get message from the receive buffer and put it into the passed in variables\r\nvoid getMessage(uint32 *macHi, uint32 *macLow, uint16 *networkAddress,\r\n    uint8 *rfData)\r\n{\r\n    \r\n    // TODO: fill in this function to tie it to the system UART\r\n    // It should implement the Zigbee Receive Packet command\r\n    \r\n}\r\n\r\n// Get message length (the length of rfData)\r\nuint8 getMessageLength(void)\r\n{\r\n    \r\n    // TODO: fill in this function to allow host processor to allocate\r\n    // proper amount of memory for getMessage command"],[1,"function"],[0,".\r\n "]],"start1":870,"start2":870,"length1":12922,"length2":16}]],"length":12908,"saved":false}
{"ts":1352707509460,"patch":[[{"diffs":[[0,"eType >> 8);"],[1,"ma"],[0,"\r\n    messag"]],"start1":1465,"start2":1465,"length1":24,"length2":26}]],"length":12910,"saved":false}
{"ts":1352707515627,"patch":[[{"diffs":[[0,"e >> 8);"],[-1,"ma"],[0,"\r\n    me"]],"start1":1469,"start2":1469,"length1":18,"length2":16}]],"length":12908,"saved":false}
{"contributors":[],"silentsave":true,"ts":1352752202917,"patch":[[{"diffs":[[0,"  myMessage."],[-1,"messageC"],[1,"c"],[0,"ount = 0;\r\n "]],"start1":7255,"start2":7255,"length1":32,"length2":25}]],"length":12901,"saved":false}
{"ts":1352752206072,"patch":[[{"diffs":[[0,"  myMessage."],[-1,"messageI"],[1,"i"],[0,"ndex = 0;\r\n "]],"start1":7281,"start2":7281,"length1":32,"length2":25}]],"length":12894,"saved":false}
{"ts":1352752209083,"patch":[[{"diffs":[[0,"  myMessage."],[-1,"messageT"],[1,"t"],[0,"ype = MESSAG"]],"start1":7307,"start2":7307,"length1":32,"length2":25}]],"length":12887,"saved":false}
{"ts":1352752212271,"patch":[[{"diffs":[[0,"  myMessage."],[-1,"messageL"],[1,"l"],[0,"ength = 0;\r\n"]],"start1":7367,"start2":7367,"length1":32,"length2":25}]],"length":12880,"saved":false}
{"ts":1352752215134,"patch":[[{"diffs":[[0,"  myMessage."],[-1,"messageD"],[1,"d"],[0,"ata = buffer"]],"start1":7394,"start2":7394,"length1":32,"length2":25}]],"length":12873,"saved":false}
{"ts":1352752350422,"patch":[[{"diffs":[[0,"  myMessage."],[-1,"messageC"],[1,"c"],[0,"ount = 0;\r\n "]],"start1":7996,"start2":7996,"length1":32,"length2":25}]],"length":12866,"saved":false}
{"ts":1352752353507,"patch":[[{"diffs":[[0,"  myMessage."],[-1,"messageI"],[1,"i"],[0,"ndex = 0;\r\n "]],"start1":8022,"start2":8022,"length1":32,"length2":25}]],"length":12859,"saved":false}
{"ts":1352752356054,"patch":[[{"diffs":[[0,"  myMessage."],[-1,"messageT"],[1,"t"],[0,"ype = MESSAG"]],"start1":8048,"start2":8048,"length1":32,"length2":25}]],"length":12852,"saved":false}
{"ts":1352752360484,"patch":[[{"diffs":[[0,"  myMessage."],[-1,"messageL"],[1,"l"],[0,"ength = 0;\r\n"]],"start1":8106,"start2":8106,"length1":32,"length2":25}]],"length":12845,"saved":false}
{"ts":1352752364130,"patch":[[{"diffs":[[0,"  myMessage."],[-1,"messageD"],[1,"d"],[0,"ata = buffer"]],"start1":8133,"start2":8133,"length1":32,"length2":25}]],"length":12838,"saved":false}
{"contributors":[],"silentsave":true,"ts":1352857907738,"patch":[[{"diffs":[[0,"ngth, uint8 "],[-1,"r"],[1,"*"],[0,"fData[])\r\n{\r"]],"start1":184,"start2":184,"length1":25,"length2":25}]],"length":12838,"saved":false}
{"ts":1352857909213,"patch":[[{"diffs":[[0," uint8 *"],[1,"r"],[0,"fData[])"]],"start1":189,"start2":189,"length1":16,"length2":17}]],"length":12839,"saved":false}
{"ts":1352857911218,"patch":[[{"diffs":[[0,"Data"],[-1,"[]"],[0,")\r\n{"]],"start1":199,"start2":199,"length1":10,"length2":8}]],"length":12837,"saved":false}
{"ts":1353093373780,"patch":[[{"diffs":[[0,"include "],[-1,"<"],[1,"\""],[0,"whan_pro"]],"start1":5,"start2":5,"length1":17,"length2":17}]],"length":12837,"saved":false}
{"ts":1353093375121,"patch":[[{"diffs":[[0,"otocol.h"],[-1,">"],[1,"\""],[0,"\r\n\r\n// T"]],"start1":21,"start2":21,"length1":17,"length2":17}]],"length":12837,"saved":false}
{"contributors":[],"silentsave":true,"ts":1353095352681,"patch":[[{"diffs":[[0,"\n\r\n#"],[-1,"IFDEF"],[1,"ifdef"],[0," COO"]],"start1":8388,"start2":8388,"length1":13,"length2":13}]],"length":12837,"saved":false}
{"ts":1353095356755,"patch":[[{"diffs":[[0,"\n\r\n#"],[-1,"ENDIF"],[1,"endif"],[0,"\r\n\r\n"]],"start1":9682,"start2":9682,"length1":13,"length2":13}]],"length":12837,"saved":false}
{"ts":1353095656963,"patch":[[{"diffs":[[0,".sourceLocale = "],[1,"get"],[0,"myLocale();\r\n   "]],"start1":2280,"start2":2280,"length1":32,"length2":35}]],"length":12840,"saved":false}
{"ts":1353095658907,"patch":[[{"diffs":[[0,"le = get"],[-1,"m"],[1,"M"],[0,"yLocale("]],"start1":2291,"start2":2291,"length1":17,"length2":17}]],"length":12840,"saved":false}
{"ts":1353095711142,"patch":[[{"diffs":[[0,"= myMessage."],[-1,"messageC"],[1,"c"],[0,"ount;\r\n    m"]],"start1":1499,"start2":1499,"length1":32,"length2":25}]],"length":12833,"saved":false}
{"ts":1353095714395,"patch":[[{"diffs":[[0,"= myMessage."],[-1,"message"],[1,"i"],[0,"Index;\r\n    "]],"start1":1540,"start2":1540,"length1":31,"length2":25}]],"length":12827,"saved":false}
{"ts":1353095716967,"patch":[[{"diffs":[[0,"essage.i"],[-1,"I"],[0,"ndex;\r\n "]],"start1":1545,"start2":1545,"length1":17,"length2":16}]],"length":12826,"saved":false}
{"ts":1353095719625,"patch":[[{"diffs":[[0,"Message."],[-1,"messageT"],[0,"ype;\r\n  "]],"start1":1585,"start2":1585,"length1":24,"length2":16}]],"length":12818,"saved":false}
{"ts":1353095720879,"patch":[[{"diffs":[[0,"Message."],[1,"t"],[0,"ype;\r\n  "]],"start1":1585,"start2":1585,"length1":16,"length2":17}]],"length":12819,"saved":false}
{"ts":1353095725956,"patch":[[{"diffs":[[0,"= myMessage."],[-1,"messageL"],[1,"l"],[0,"ength;\r\n    "]],"start1":1621,"start2":1621,"length1":32,"length2":25}]],"length":12812,"saved":false}
{"ts":1353095731082,"patch":[[{"diffs":[[0,"= myMessage."],[-1,"messageL"],[1,"l"],[0,"ength + 7;\r\n"]],"start1":1225,"start2":1225,"length1":32,"length2":25}]],"length":12805,"saved":false}
{"ts":1353095757391,"patch":[[{"diffs":[[0," 0; i < "],[-1,"message"],[1,"rfData"],[0,"Length; "]],"start1":1653,"start2":1653,"length1":23,"length2":22}]],"length":12804,"saved":false}
{"ts":1353095764908,"patch":[[{"diffs":[[0,"Message."],[-1,"messageD"],[1,"d"],[0,"ata[i];\r"]],"start1":1720,"start2":1720,"length1":24,"length2":17}]],"length":12797,"saved":false}
{"ts":1353095815486,"patch":[[{"diffs":[[0,"\r\n    myMessage."],[-1,"d"],[1,"sourceD"],[0,"eviceType = MY_D"]],"start1":2267,"start2":2267,"length1":33,"length2":39}]],"length":12803,"saved":false}
{"ts":1353095875395,"patch":[[{"diffs":[[0,"  myMessage."],[-1,"messageC"],[1,"c"],[0,"ount = 0;\r\n "]],"start1":3160,"start2":3160,"length1":32,"length2":25}]],"length":12796,"saved":false}
{"ts":1353095879110,"patch":[[{"diffs":[[0,"  myMessage."],[-1,"messageC"],[1,"c"],[0,"ount = 0;\r\n "]],"start1":2321,"start2":2321,"length1":32,"length2":25}]],"length":12789,"saved":false}
{"ts":1353095880759,"patch":[[{"diffs":[[0,"  myMessage."],[-1,"messageC"],[1,"c"],[0,"ount = 0;//T"]],"start1":3879,"start2":3879,"length1":32,"length2":25}]],"length":12782,"saved":false}
{"ts":1353095882646,"patch":[[{"diffs":[[0,"  myMessage."],[-1,"messageC"],[1,"c"],[0,"ount = 0;//T"]],"start1":5065,"start2":5065,"length1":32,"length2":25}]],"length":12775,"saved":false}
{"ts":1353095887463,"patch":[[{"diffs":[[0,"  myMessage."],[-1,"messageC"],[1,"c"],[0,"ount = 0;\r\n "]],"start1":6624,"start2":6624,"length1":32,"length2":25}]],"length":12768,"saved":false}
{"ts":1353095888496,"patch":[[{"diffs":[[0,"  myMessage."],[-1,"messageC"],[1,"c"],[0,"ount = 0;\r\n "]],"start1":6164,"start2":6164,"length1":32,"length2":25}]],"length":12761,"saved":false}
{"ts":1353095894189,"patch":[[{"diffs":[[0,"  myMessage."],[-1,"messageC"],[1,"c"],[0,"ount = 0;\r\n "]],"start1":8754,"start2":8754,"length1":32,"length2":25}]],"length":12754,"saved":false}
{"ts":1353095896433,"patch":[[{"diffs":[[0,"age."],[-1,"messageC"],[1,"c"],[0,"ount"]],"start1":9973,"start2":9973,"length1":16,"length2":9}]],"length":12747,"saved":false}
{"ts":1353095905965,"patch":[[{"diffs":[[0,"  myMessage."],[-1,"messageI"],[1,"i"],[0,"ndex = 0;\r\n "]],"start1":9991,"start2":9991,"length1":32,"length2":25}]],"length":12740,"saved":false}
{"ts":1353095912696,"patch":[[{"diffs":[[0,"  myMessage."],[-1,"messageI"],[1,"i"],[0,"ndex = 0;\r\n "]],"start1":8780,"start2":8780,"length1":32,"length2":25}]],"length":12733,"saved":false}
{"ts":1353095917708,"patch":[[{"diffs":[[0,"  myMessage."],[-1,"messageI"],[1,"i"],[0,"ndex = 0;\r\n "]],"start1":6643,"start2":6643,"length1":32,"length2":25}]],"length":12726,"saved":false}
{"ts":1353095920836,"patch":[[{"diffs":[[0,"  myMessage."],[-1,"messageI"],[1,"i"],[0,"ndex = 0;\r\n "]],"start1":6190,"start2":6190,"length1":32,"length2":25}]],"length":12719,"saved":false}
{"ts":1353095923847,"patch":[[{"diffs":[[0,"  myMessage."],[-1,"messageI"],[1,"i"],[0,"ndex = 0;\r\n "]],"start1":5133,"start2":5133,"length1":32,"length2":25}]],"length":12712,"saved":false}
{"ts":1353095926606,"patch":[[{"diffs":[[0,"  myMessage."],[-1,"messageI"],[1,"i"],[0,"ndex = 0;\r\n "]],"start1":3947,"start2":3947,"length1":32,"length2":25}]],"length":12705,"saved":false}
{"ts":1353095929800,"patch":[[{"diffs":[[0,"  myMessage."],[-1,"messageI"],[1,"i"],[0,"ndex = 0;\r\n "]],"start1":3179,"start2":3179,"length1":32,"length2":25}]],"length":12698,"saved":false}
{"ts":1353095932286,"patch":[[{"diffs":[[0,"age."],[-1,"messageI"],[1,"i"],[0,"ndex"]],"start1":2355,"start2":2355,"length1":16,"length2":9}]],"length":12691,"saved":false}
{"ts":1353095941291,"patch":[[{"diffs":[[0,"  myMessage."],[-1,"messageT"],[1,"t"],[0,"ype = MESSAG"]],"start1":2373,"start2":2373,"length1":32,"length2":25}]],"length":12684,"saved":false}
{"ts":1353095944737,"patch":[[{"diffs":[[0,"  myMessage."],[-1,"messageT"],[1,"t"],[0,"ype = MESSAG"]],"start1":3191,"start2":3191,"length1":32,"length2":25}]],"length":12677,"saved":false}
{"ts":1353095948747,"patch":[[{"diffs":[[0,"  myMessage."],[-1,"messageT"],[1,"t"],[0,"ype = MESSAG"]],"start1":3945,"start2":3945,"length1":32,"length2":25}]],"length":12670,"saved":false}
{"ts":1353095952474,"patch":[[{"diffs":[[0,"  myMessage."],[-1,"messageT"],[1,"t"],[0,"ype = MESSAG"]],"start1":5117,"start2":5117,"length1":32,"length2":25}]],"length":12663,"saved":false}
{"ts":1353095954496,"patch":[[{"diffs":[[0,"  myMessage."],[-1,"messageT"],[1,"t"],[0,"ype = MESSAG"]],"start1":6160,"start2":6160,"length1":32,"length2":25}]],"length":12656,"saved":false}
{"ts":1353095957546,"patch":[[{"diffs":[[0,"  myMessage."],[-1,"messageT"],[1,"t"],[0,"ype = MESSAG"]],"start1":6599,"start2":6599,"length1":32,"length2":25}]],"length":12649,"saved":false}
{"ts":1353095963612,"patch":[[{"diffs":[[0,"  myMessage."],[-1,"messageT"],[1,"t"],[0,"ype = MESSAG"]],"start1":8722,"start2":8722,"length1":32,"length2":25}]],"length":12642,"saved":false}
{"ts":1353095998428,"patch":[[{"diffs":[[0,"\r\n    myMessage."],[-1,"d"],[1,"sourceD"],[0,"eviceType = MY_D"]],"start1":7787,"start2":7787,"length1":33,"length2":39}]],"length":12648,"saved":false}
{"ts":1353095999728,"patch":[[{"diffs":[[0,"\r\n    myMessage."],[-1,"d"],[1,"sourceD"],[0,"eviceType = MY_D"]],"start1":3091,"start2":3091,"length1":33,"length2":39}]],"length":12654,"saved":false}
{"ts":1353096014966,"patch":[[{"diffs":[[0,"  myMessage."],[-1,"messageL"],[1,"l"],[0,"ength = 6;\r\n"]],"start1":2422,"start2":2422,"length1":32,"length2":25}]],"length":12647,"saved":false}
{"ts":1353096048603,"patch":[[{"diffs":[[0,"  myMessage."],[-1,"messageL"],[1,"l"],[0,"ength = 1;\r\n"]],"start1":3239,"start2":3239,"length1":32,"length2":25}]],"length":12640,"saved":false}
{"ts":1353096070218,"patch":[[{"diffs":[[0,"\r\n    myMessage."],[-1,"l"],[1,"messageL"],[0,"ength = 1;\r\n    "]],"start1":3235,"start2":3235,"length1":33,"length2":40}]],"length":12647,"saved":false}
{"ts":1353096071916,"patch":[[{"diffs":[[0,"  myMessage."],[-1,"messageL"],[1,"l"],[0,"ength = 1;\r\n"]],"start1":3239,"start2":3239,"length1":32,"length2":25}]],"length":12640,"saved":false}
{"ts":1353096128609,"patch":[[{"diffs":[[0,"  myMessage."],[-1,"messageL"],[1,"l"],[0,"ength = buff"]],"start1":3986,"start2":3986,"length1":32,"length2":25}]],"length":12633,"saved":false}
{"ts":1353096131853,"patch":[[{"diffs":[[0,"  myMessage."],[-1,"messageD"],[1,"d"],[0,"ata = buffer"]],"start1":4021,"start2":4021,"length1":32,"length2":25}]],"length":12626,"saved":false}
{"ts":1353096136686,"patch":[[{"diffs":[[0,"  myMessage."],[-1,"messageD"],[1,"d"],[0,"ata = buffer"]],"start1":5186,"start2":5186,"length1":32,"length2":25}]],"length":12619,"saved":false}
{"ts":1353096139973,"patch":[[{"diffs":[[0,"  myMessage."],[-1,"messageL"],[1,"l"],[0,"ength = buff"]],"start1":5144,"start2":5144,"length1":32,"length2":25}]],"length":12612,"saved":false}
{"ts":1353096145703,"patch":[[{"diffs":[[0,"  myMessage."],[-1,"messageL"],[1,"l"],[0,"ength = 0;\r\n"]],"start1":6617,"start2":6617,"length1":32,"length2":25}]],"length":12605,"saved":false}
{"ts":1353096153332,"patch":[[{"diffs":[[0,"  myMessage."],[-1,"messageL"],[1,"l"],[0,"ength = 12 +"]],"start1":8743,"start2":8743,"length1":32,"length2":25}]],"length":12598,"saved":false}
{"ts":1353096155699,"patch":[[{"diffs":[[0,"  myMessage."],[-1,"messageD"],[1,"d"],[0,"ata = buffer"]],"start1":8789,"start2":8789,"length1":32,"length2":25}]],"length":12591,"saved":false}
{"ts":1353096163603,"patch":[[{"diffs":[[0,"age."],[-1,"messageT"],[1,"t"],[0,"ype "]],"start1":9876,"start2":9876,"length1":16,"length2":9}]],"length":12584,"saved":false}
{"ts":1353096166909,"patch":[[{"diffs":[[0,"  myMessage."],[-1,"messageL"],[1,"l"],[0,"ength = 0;\r\n"]],"start1":9917,"start2":9917,"length1":32,"length2":25}]],"length":12577,"saved":false}
{"ts":1353096176358,"patch":[[{"diffs":[[0,"\r\n    myMessage."],[1,"source"],[0,"deviceType = MY_"]],"start1":9768,"start2":9768,"length1":32,"length2":38}]],"length":12583,"saved":false}
{"ts":1353096177769,"patch":[[{"diffs":[[0,"e.source"],[-1,"d"],[1,"D"],[0,"eviceTyp"]],"start1":9782,"start2":9782,"length1":17,"length2":17}]],"length":12583,"saved":false}
{"contributors":[],"silentsave":true,"ts":1353096460101,"patch":[[{"diffs":[[0,"  myMessage."],[-1,"messageD"],[1,"d"],[0,"ata = buffer"]],"start1":2449,"start2":2449,"length1":32,"length2":25},{"diffs":[[0,"Message."],[-1,"messageD"],[1,"d"],[0,"ata = bu"]],"start1":3263,"start2":3263,"length1":24,"length2":17}]],"length":12569,"saved":false}
{"ts":1353096500742,"patch":[[{"diffs":[[0,"\r\n    myMessage."],[-1,"d"],[1,"sourceD"],[0,"eviceType = MY_D"]],"start1":3781,"start2":3781,"length1":33,"length2":39},{"diffs":[[0,"\r\n    myMessage."],[-1,"d"],[1,"sourceD"],[0,"eviceType = MY_D"]],"start1":4945,"start2":4945,"length1":33,"length2":39},{"diffs":[[0,"\r\n    myMessage."],[-1,"d"],[1,"sourceD"],[0,"eviceType = MY_D"]],"start1":6022,"start2":6022,"length1":33,"length2":39},{"diffs":[[0,"\r\n    myMessage."],[-1,"d"],[1,"sourceD"],[0,"eviceType = MY_D"]],"start1":6467,"start2":6467,"length1":33,"length2":39},{"diffs":[[0,"\r\n    myMessage."],[-1,"d"],[1,"sourceD"],[0,"eviceType = MY_D"]],"start1":7013,"start2":7013,"length1":33,"length2":39},{"diffs":[[0,"Message."],[-1,"d"],[1,"sourceD"],[0,"eviceTyp"]],"start1":8609,"start2":8609,"length1":17,"length2":23}]],"length":12605,"saved":false}
{"ts":1353096542654,"patch":[[{"diffs":[[0,"age."],[-1,"messageL"],[1,"l"],[0,"engt"]],"start1":6193,"start2":6193,"length1":16,"length2":9}]],"length":12598,"saved":false}
