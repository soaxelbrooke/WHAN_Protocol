{"ts":1352707207034,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"\r\n#include <whan_protocol.h>\r\n\r\nstatic uint8 myCapabilities[] = {UNIT_TYPE_DEGREES_C_ENVIRONMENT,\r\n    UNIT_TYPE_PRESSURE, UNIT_TYPE_LUMENS};\r\nstatic uint8 myInterests[] = {UNIT_TYPE_OCCUPANTS};\r\n    \r\nstatic uint8 myInterests[0]; // No interests\r\n\r\n\r\n// Function pointers\r\nvoid serviceSubscribeRequest(uint16 networkAddress, uint32 macHi, uint32 macLow,\r\n    message *myMessage);\r\nvoid serviceSubscribeInstruction(uint16 networkAddress, uint32 macHi, \r\n    uint32 macLow, message *myMessage);\r\nvoid serviceNotificationRequest(uint16 networkAddress, message *myMessage);\r\nint32 getLastMeasurement(uint8 type);\r\nvoid sleepForTenMinutes(void);\r\nvoid init(void);\r\nint32 measureTemp(void);\r\nint32 measurePressure(void);\r\nint32 measureLumens(void);\r\n\r\n// Main loop\r\nvoid main(void)\r\n{\r\n    // Initialize variables for measurements\r\n    int32 temperature, pressure, light;\r\n    // Initialize notification struct\r\n    notification myNotification;\r\n    \r\n    // Point struct to lists in memory\r\n    int32 notifData[3];\r\n    int8 notifTypes[3];\r\n    myNotification.data = notifData;\r\n    myNotification.types = notifTypes;\r\n    // Specify number of notifications\r\n    myNotification.numNotifications = 3;\r\n    \r\n    // Initialize some stuff\r\n    init();\r\n    \r\n    // Send measurement capabilities to coordinator\r\n    void sendCapabilitiesNotification(MY_NUM_CAPABILITIES, myCapabilities);\r\n    \r\n    \r\n    // Send measurement interests to cooridnator\r\n    sendInterestsNotification(MY_NUM_INTERESTS, myInterests,uint8 *locales);\r\n    \r\n    while(1)\r\n    {\r\n        // Measure temperature\r\n        temperature = measureTemp();\r\n        // Put measured temp data into struct\r\n        myNotification.data[0] = temperature;\r\n        myNotification.types[0] = UNIT_TYPE_DEGREES_C_ENVIRONMENT;\r\n        \r\n        // Measure pressure\r\n        pressure = measurePressure();\r\n        // Put measured pressure data into struct\r\n        myNotificaiton.data[1] = pressure;\r\n        myNotification.types[1] = UNIT_TYPE_PRESSURE;\r\n        \r\n        // Measure light\r\n        light = measureLight();\r\n        // Put measured light data into struct\r\n        myNotification.data[2] = light;\r\n        myNotification.types[2] = UNIT_TYPE_LUMENS;\r\n        \r\n        // Send notification data to address book entries that are interested\r\n        notifyInterestedNodes(myNotification);\r\n        \r\n        // Wait for a while\r\n        sleepForTenMinutes();\r\n        \r\n    }\r\n    \r\n}\r\n\r\n// Should be called when a Subscribe Request has been received\r\nvoid serviceSubscribeRequest(uint16 networkAddress, uint32 macHi, uint32 macLow,\r\n    message *myMessage)\r\n{\r\n    // Add node to address book (if there is space)\r\n    if (numFreeAddressEntries() > 0)\r\n    {\r\n        addNodeToAddressBook(networkAddress, macHi, macLow, \r\n            *myMessage.sourceLocale, *myMessage.data[0],\r\n            (uint8*)(*myMessage.data + 1), 0, myCapabilities);\r\n            \r\n    }\r\n    \r\n}\r\n\r\n// Should be called when a Subscribe Instruction has been received\r\nvoid serviceSubscribeInstruction(uint16 networkAddress, uint32 macHi, \r\n    uint32 macLow, message *myMessage)\r\n{\r\n    // Get data needed to add node to address book\r\n    uint16 targetNetworkAddress = *myMessage.data[1] + \r\n        (*myMessage.data[0] << 8);\r\n    uint32 targetMacHi = *myMessage.data[5] + \r\n        (*myMessage.data[4] << 8) + \r\n        (*myMessage.data[3] << 16) + \r\n        (*myMessage.data[2] << 24);\r\n    uint32 targetMacLow = *myMessage.data[9] + \r\n        (*myMessage.data[8] << 8) + \r\n        (*myMessage.data[7] << 16) + \r\n        (*myMessage.data[6] << 24);\r\n    uint8 targetLocale = *myMessage.data[10];\r\n    uint8 targetNumCapabilities = *myMessage.data[11];\r\n    uint8 *targetCapabilities = (uint8*)(*myMessage.data + 12);\r\n    \r\n    // Add node to address book (if there is space)\r\n    if (numFreeAddressEntries() > 0)\r\n    {\r\n        addNodeToAddressBook(targetNetworkAddress, targetMacHi, targetMacLow,\r\n            targetLocale, 0, myInterests, targetNumCapabilities,\r\n            targetCapabilities);\r\n    }\r\n    \r\n    // Request subscription from target node\r\n    sendSubscribeRequest(targetNetworkAddress, MY_NUM_INTERESTS, myInterests);\r\n    \r\n}\r\n\r\n// Should be called when a Notification Request command has been received\r\nvoid serviceNotificationRequest(uint16 networkAddress, message *myMessage)\r\n{\r\n    // Declare variables to be used in this context\r\n    uint8 i = 0, j = 0;\r\n    notificaiton N;\r\n    uint32 nData[MY_NUM_CAPABILITIES];\r\n    uint8 nTypes[MY_NUM_CAPABILITIES];\r\n    \r\n    // Set up struct pointers to lists on stack\r\n    N.numNotifications = 0;\r\n    N.data = nData;\r\n    N.types = nTypes;\r\n    \r\n    // For all types that are in both the notification request and this node's\r\n    // list of capabilities, append their latest measurements to the\r\n    // notification\r\n    for (i = 0; i < MY_NUM_CAPABILITIES; i++)\r\n    {\r\n        for (j = 0; j < *myMessage.data[0]; j++)\r\n        {\r\n            if (myCapabilities[i] == *myMessage.data[j+1])\r\n            {\r\n                // If one of this node's capabilities are found in the\r\n                // notification request, add to the notification\r\n                N.data[N.numNotifications] = getLastMeasurement(*myMessage.data[j+1]);\r\n                N.types[N.numNotifications] = *myMessage.data[j+1];\r\n                N.numNotifications += 1;\r\n                \r\n            }\r\n        }\r\n    }\r\n    \r\n    // If there are notifications to be sent, send them\r\n    if (N.numNotifications > 0)\r\n    {\r\n        sendNotification(uint16 networkAddress, N);\r\n    }\r\n    \r\n}\r\n\r\n// Retrieves the last measurement of a given type\r\nint32 getLastMeasurement(uint8 type)\r\n{\r\n    int32 result = 0;\r\n    \r\n    if (type == UNIT_TYPE_DEGREES_C_ENVIRONMENT)\r\n    {\r\n        result = measureTemp();\r\n    }\r\n    else if (type == UNIT_TYPE_PRESSURE)\r\n    {\r\n        result = measurePressure();\r\n    } \r\n    else if (type == UNIT_TYPE_LUMENS)\r\n    {\r\n        result = measureLumens();\r\n    }\r\n    \r\n    return result;\r\n    \r\n}\r\n\r\n// Sleep for ten minutes\r\nvoid sleepForTenMinutes(void)\r\n{\r\n    return; // It's a very fast ten minutes.\r\n}\r\n\r\nvoid init(void)\r\n{\r\n    return; // Not much to initialize, I suppose...\r\n}\r\n\r\nint32 measureTemp(void)\r\n{\r\n    return 0x00000001;\r\n}\r\n\r\nint32 measurePressure(void)\r\n{\r\n    return 0x00000002;\r\n}\r\n\r\nint32 measureLumens(void)\r\n{\r\n    return 0x00000003;\r\n}\r\n"]],"start1":0,"start2":0,"length1":0,"length2":6389}]],"length":6389}
{"contributors":[],"silentsave":false,"ts":1352707206961,"patch":[[{"diffs":[[1,"\r\n#include <whan_protocol.h>\r\n\r\nstatic uint8 myCapabilities[] = {UNIT_TYPE_DEGREES_C_ENVIRONMENT,\r\n    UNIT_TYPE_PRESSURE, UNIT_TYPE_LUMENS};\r\nstatic uint8 myInterests[] = {UNIT_TYPE_OCCUPANTS};\r\n    \r\nstatic uint8 myInterests[0]; // No interests\r\n\r\n\r\n// Function pointers\r\nvoid serviceSubscribeRequest(uint16 networkAddress, uint32 macHi, uint32 macLow,\r\n    message *myMessage);\r\nvoid serviceSubscribeInstruction(uint16 networkAddress, uint32 macHi, \r\n    uint32 macLow, message *myMessage);\r\nvoid serviceNotificationRequest(uint16 networkAddress, message *myMessage);\r\nint32 getLastMeasurement(uint8 type);\r\nvoid sleepForTenMinutes(void);\r\nvoid init(void);\r\nint32 measureTemp(void);\r\nint32 measurePressure(void);\r\nint32 measureLumens(void);\r\n\r\n// Main loop\r\nvoid main(void)\r\n{\r\n    // Initialize variables for measurements\r\n    int32 temperature, pressure, light;\r\n    // Initialize notification struct\r\n    notification myNotification;\r\n    \r\n    // Point struct to lists in memory\r\n    int32 notifData[3];\r\n    int8 notifTypes[3];\r\n    myNotification.data = notifData;\r\n    myNotification.types = notifTypes;\r\n    // Specify number of notifications\r\n    myNotification.numNotifications = 3;\r\n    \r\n    // Initialize some stuff\r\n    init();\r\n    \r\n    // Send measurement capabilities to coordinator\r\n    void sendCapabilitiesNotification(MY_NUM_CAPABILITIES, myCapabilities);\r\n    \r\n    \r\n    // Send measurement interests to cooridnator\r\n    sendInterestsNotification(MY_NUM_INTERESTS, myInterests,uint8 *locales);\r\n    \r\n    while(1)\r\n    {\r\n        // Measure temperature\r\n        temperature = measureTemp();\r\n        // Put measured temp data into struct\r\n        myNotification.data[0] = temperature;\r\n        myNotification.types[0] = UNIT_TYPE_DEGREES_C_ENVIRONMENT;\r\n        \r\n        // Measure pressure\r\n        pressure = measurePressure();\r\n        // Put measured pressure data into struct\r\n        myNotificaiton.data[1] = pressure;\r\n        myNotification.types[1] = UNIT_TYPE_PRESSURE;\r\n        \r\n        // Measure light\r\n        light = measureLight();\r\n        // Put measured light data into struct\r\n        myNotification.data[2] = light;\r\n        myNotification.types[2] = UNIT_TYPE_LUMENS;\r\n        \r\n        // Send notification data to address book entries that are interested\r\n        notifyInterestedNodes(myNotification);\r\n        \r\n        // Wait for a while\r\n        sleepForTenMinutes();\r\n        \r\n    }\r\n    \r\n}\r\n\r\n// Should be called when a Subscribe Request has been received\r\nvoid serviceSubscribeRequest(uint16 networkAddress, uint32 macHi, uint32 macLow,\r\n    message *myMessage)\r\n{\r\n    // Add node to address book (if there is space)\r\n    if (numFreeAddressEntries() > 0)\r\n    {\r\n        addNodeToAddressBook(networkAddress, macHi, macLow, \r\n            *myMessage.sourceLocale, *myMessage.data[0],\r\n            (uint8*)(*myMessage.data + 1), 0, myCapabilities);\r\n            \r\n    }\r\n    \r\n}\r\n\r\n// Should be called when a Subscribe Instruction has been received\r\nvoid serviceSubscribeInstruction(uint16 networkAddress, uint32 macHi, \r\n    uint32 macLow, message *myMessage)\r\n{\r\n    // Get data needed to add node to address book\r\n    uint16 targetNetworkAddress = *myMessage.data[1] + \r\n        (*myMessage.data[0] << 8);\r\n    uint32 targetMacHi = *myMessage.data[5] + \r\n        (*myMessage.data[4] << 8) + \r\n        (*myMessage.data[3] << 16) + \r\n        (*myMessage.data[2] << 24);\r\n    uint32 targetMacLow = *myMessage.data[9] + \r\n        (*myMessage.data[8] << 8) + \r\n        (*myMessage.data[7] << 16) + \r\n        (*myMessage.data[6] << 24);\r\n    uint8 targetLocale = *myMessage.data[10];\r\n    uint8 targetNumCapabilities = *myMessage.data[11];\r\n    uint8 *targetCapabilities = (uint8*)(*myMessage.data + 12);\r\n    \r\n    // Add node to address book (if there is space)\r\n    if (numFreeAddressEntries() > 0)\r\n    {\r\n        addNodeToAddressBook(targetNetworkAddress, targetMacHi, targetMacLow,\r\n            targetLocale, 0, myInterests, targetNumCapabilities,\r\n            targetCapabilities);\r\n    }\r\n    \r\n    // Request subscription from target node\r\n    sendSubscribeRequest(targetNetworkAddress, MY_NUM_INTERESTS, myInterests);\r\n    \r\n}\r\n\r\n// Should be called when a Notification Request command has been received\r\nvoid serviceNotificationRequest(uint16 networkAddress, message *myMessage)\r\n{\r\n    // Declare variables to be used in this context\r\n    uint8 i = 0, j = 0;\r\n    notificaiton N;\r\n    uint32 nData[MY_NUM_CAPABILITIES];\r\n    uint8 nTypes[MY_NUM_CAPABILITIES];\r\n    \r\n    // Set up struct pointers to lists on stack\r\n    N.numNotifications = 0;\r\n    N.data = nData;\r\n    N.types = nTypes;\r\n    \r\n    // For all types that are in both the notification request and this node's\r\n    // list of capabilities, append their latest measurements to the\r\n    // notification\r\n    for (i = 0; i < MY_NUM_CAPABILITIES; i++)\r\n    {\r\n        for (j = 0; j < *myMessage.data[0]; j++)\r\n        {\r\n            if (myCapabilities[i] == *myMessage.data[j+1])\r\n            {\r\n                // If one of this node's capabilities are found in the\r\n                // notification request, add to the notification\r\n                N.data[N.numNotifications] = getLastMeasurement(*myMessage.data[j+1]);\r\n                N.types[N.numNotifications] = *myMessage.data[j+1];\r\n                N.numNotifications += 1;\r\n                \r\n            }\r\n        }\r\n    }\r\n    \r\n    // If there are notifications to be sent, send them\r\n    if (N.numNotifications > 0)\r\n    {\r\n        sendNotification(uint16 networkAddress, N);\r\n    }\r\n    \r\n}\r\n\r\n// Retrieves the last measurement of a given type\r\nint32 getLastMeasurement(uint8 type)\r\n{\r\n    int32 result = 0;\r\n    \r\n    if (type == UNIT_TYPE_DEGREES_C_ENVIRONMENT)\r\n    {\r\n        result = measureTemp();\r\n    }\r\n    else if (type == UNIT_TYPE_PRESSURE)\r\n    {\r\n        result = measurePressure();\r\n    } \r\n    else if (type == UNIT_TYPE_LUMENS)\r\n    {\r\n        result = measureLumens();\r\n    }\r\n    \r\n    return result;\r\n    \r\n}\r\n\r\n// Sleep for ten minutes\r\nvoid sleepForTenMinutes(void)\r\n{\r\n    return; // It's a very fast ten minutes.\r\n}\r\n\r\nvoid init(void)\r\n{\r\n    return; // Not much to initialize, I suppose...\r\n}\r\n\r\nint32 measureTemp(void)\r\n{\r\n    return 0x00000001;\r\n}\r\n\r\nint32 measurePressure(void)\r\n{\r\n    return 0x00000002;\r\n}\r\n\r\nint32 measureLumens(void)\r\n{\r\n    return 0x00000003;\r\n}\r\n"]],"start1":0,"start2":0,"length1":0,"length2":6389}]],"length":6389,"saved":false}
{"contributors":[],"silentsave":true,"ts":1352707422939,"patch":[[{"diffs":[[0,"  \r\n"],[-1,"static uint8 myInterests[0]; // No interests\r\n\r\n\r\n// Function pointers\r\nvoid serviceSubscribeRequest(uint16 networkAddress, uint32 macHi, uint32 macLow,\r\n    message *myMessage);\r\nvoid serviceSubscribeInstruction(uint16 networkAddress, uint32 macHi, \r\n    uint32 macLow, message *myMessage);\r\nvoid serviceNotificationRequest(uint16 networkAddress, message *myMessage);\r\nint32 getLastMeasurement(uint8 type);\r\nvoid sleepForTenMinutes(void);\r\nvoid init(void);\r\nint32 measureTemp(void);\r\nint32 measurePressure(void);\r\nint32 measureLumens(void);\r\n\r\n// Main loop\r\nvoid main(void)\r\n{\r\n    // Initialize variables for measurements\r\n    int32 temperature, pressure, light;\r\n    // Initialize notification struct\r\n    notification myNotification;\r\n    \r\n    // Point struct to lists in memory\r\n    int32 notifData[3];\r\n    int8 notifTypes[3];\r\n    myNotification.data = notifData;\r\n    myNotification.types = notifTypes;\r\n    // Specify number of notifications\r\n    myNotification.numNotifications = 3;\r\n    \r\n    // Initialize some stuff\r\n    init();\r\n    \r\n    // Send measurement capabilities to coordinator\r\n    void sendCapabilitiesNotification(MY_NUM_CAPABILITIES, myCapabilities);\r\n    \r\n    \r\n    // Send measurement interests to cooridnator\r\n    sendInterestsNotification(MY_NUM_INTERESTS, myInterests,uint8 *locales);\r\n    \r\n    while(1)\r\n    {\r\n        // Measure temperature\r\n        temperature = measureTemp();\r\n        // Put measured temp data into struct\r\n        myNotification.data[0] = temperature;\r\n        myNotification.types[0] = UNIT_TYPE_DEGREES_C_ENVIRONMENT;\r\n        \r\n        // Measure pressure\r\n        pressure = measurePressure();\r\n        // Put measured pressure data into struct\r\n        myNotificaiton.data[1] = pressure;\r\n        myNotification.types[1] = UNIT_TYPE_PRESSURE;\r\n        \r\n        // Measure light\r\n        light = measureLight();\r\n        // Put measured light data into struct\r\n        myNotification.data[2] = light;\r\n        myNotification.types[2] = UNIT_TYPE_LUMENS;\r\n        \r\n        // Send notification data to address book entries that are interested\r\n        notifyInterestedNodes(myNotification);\r\n        \r\n        // Wait for a while\r\n        sleepForTenMinutes();\r\n        \r\n    }\r\n    \r\n}\r\n\r\n// Should be called when a Subscribe Request has been received\r\nvoid serviceSubscribeRequest(uint16 networkAddress, uint32 macHi, uint32 macLow,\r\n    message *myMessage)\r\n{\r\n    // Add node to address book (if there is space)\r\n    if (numFreeAddressEntries() > 0)\r\n    {\r\n        addNodeToAddressBook(networkAddress, macHi, macLow, \r\n            *myMessage.sourceLocale, *myMessage.data[0],\r\n            (uint8*)(*myMessage.data + 1), 0, myCapabilities);\r\n            \r\n    }\r\n    \r\n}\r\n\r\n// Should be called when a Subscribe Instruction has been received\r\nvoid serviceSubscribeInstruction(uint16 networkAddress, uint32 macHi, \r\n    uint32 macLow, message *myMessage)\r\n{\r\n    // Get data needed to add node to address book\r\n    uint16 targetNetworkAddress = *myMessage.data[1] + \r\n        (*myMessage.data[0] << 8);\r\n    uint32 targetMacHi = *myMessage.data[5] + \r\n        (*myMessage.data[4] << 8) + \r\n        (*myMessage.data[3] << 16) + \r\n        (*myMessage.data[2] << 24);\r\n    uint32 targetMacLow = *myMessage.data[9] + \r\n        (*myMessage.data[8] << 8) + \r\n        (*myMessage.data[7] << 16) + \r\n        (*myMessage.data[6] << 24);\r\n    uint8 targetLocale = *myMessage.data[10];\r\n    uint8 targetNumCapabilities = *myMessage.data[11];\r\n    uint8 *targetCapabilities = (uint8*)(*myMessage.data + 12);\r\n    \r\n    // Add node to address book (if there is space)\r\n    if (numFreeAddressEntries() > 0)\r\n    {\r\n        addNodeToAddressBook(targetNetworkAddress, targetMacHi, targetMacLow,\r\n            targetLocale, 0, myInterests, targetNumCapabilities,\r\n            targetCapabilities);\r\n    }\r\n    \r\n    // Request subscription from target node\r\n    sendSubscribeRequest(targetNetworkAddress, MY_NUM_INTERESTS, myInterests);\r\n    \r\n}\r\n\r\n// Should be called when a Notification Request command has been received\r\nvoid serviceNotificationRequest(uint16 networkAddress, message *myMessage)\r\n{\r\n    // Declare variables to be used in this context\r\n    uint8 i = 0, j = 0;\r\n    notificaiton N;\r\n    uint32 nData[MY_NUM_CAPABILITIES];\r\n    uint8 nTypes[MY_NUM_CAPABILITIES];\r\n    \r\n    // Set up struct pointers to lists on stack\r\n    N.numNotifications = 0;\r\n    N.data = nData;\r\n    N.types = nTypes;\r\n    \r\n    // For all types that are in both the notification request and this node's\r\n    // list of capabilities, append their latest measurements to the\r\n    // notification\r\n    for (i = 0; i < MY_NUM_CAPABILITIES; i++)\r\n    {\r\n        for (j = 0; j < *myMessage.data[0]; j++)\r\n        {\r\n            if (myCapabilities[i] == *myMessage.data[j+1])\r\n            {\r\n                // If one of this node's capabilities are found in the\r\n                // notification request, add to the notification\r\n                N.data[N.numNotifications] = getLastMeasurement(*myMessage.data[j+1]);\r\n                N.types[N.numNotifications] = *myMessage.data[j+1];\r\n                N.numNotifications += 1;\r\n                \r\n            }\r\n        }\r\n    }\r\n    \r\n    // If there are notifications to be sent, send them\r\n    if (N.numNotifications > 0)\r\n    {\r\n        sendNotification(uint16 networkAddress, N);\r\n    }\r\n    \r\n}\r\n\r\n// Retrieves the last measurement of a given type\r\nint32 getLastMeasurement(uint8 type)\r\n{\r\n    int32 result = 0;\r\n    \r\n    if (type == UNIT_TYPE_DEGREES_C_ENVIRONMENT)\r\n    {\r\n        result = measureTemp();\r\n    }\r\n    else if (type == UNIT_TYPE_PRESSURE)\r\n    {\r\n        result = measurePressure();\r\n    } \r\n    else if (type == UNIT_TYPE_LUMENS)\r\n    {\r\n        result = measureLumens();\r\n    }\r\n    \r\n    return result;\r\n    \r\n}\r\n\r\n// Sleep for ten minutes\r\nvoid sleepForTenMinutes(void)\r\n{\r\n    return; // It's a very fast ten minutes.\r\n}\r\n\r\nvoid init(void)\r\n{\r\n    return; // Not much to initialize, I suppose...\r\n}\r\n\r\nint32 measureTemp(void)\r\n{\r\n    return 0x00000001;\r\n}\r\n\r\nint32 measurePressure(void)\r\n{\r\n    return 0x00000002;\r\n}\r\n\r\nint32 measureLumens(void)\r\n{\r\n    return 0x00000003;\r\n}\r\n\r\n#include <whan_protocol.h>\r\n\r\nstatic uint8 myCapabilities[] = {UNIT_TYPE_DEGREES_C_ENVIRONMENT,\r\n    UNIT_TYPE_PRESSURE, UNIT_TYPE_LUMENS};\r\nstatic uint8 myInterests[] = {UNIT_TYPE_OCCUPANTS};\r\n    \r\nstatic uint8 myInterests[0]; // No interests\r\n"],[0,"\r\n\r\n"]],"start1":198,"start2":198,"length1":6443,"length2":8}]],"length":6343,"saved":false}
{"ts":1352707424332,"patch":[[{"diffs":[[0,"ANTS};\r\n"],[-1,"    \r\n"],[0,"\r\n\r\n// F"]],"start1":188,"start2":188,"length1":22,"length2":16}]],"length":6337,"saved":false}
{"contributors":[],"silentsave":true,"ts":1352749710800,"patch":[[{"diffs":[[0," }\r\n        "],[-1,"}"],[1,"    \r\n        }\r\n        "],[0,"\r\n    }\r\n   "]],"start1":5339,"start2":5339,"length1":25,"length2":49}]],"length":6361,"saved":false}
{"ts":1352749790399,"patch":[[{"diffs":[[0,"dress, N);\r\n"],[1,"        \r\n"],[0,"    }\r\n    \r"]],"start1":5529,"start2":5529,"length1":24,"length2":34}]],"length":6371,"saved":false}
{"ts":1352751966415,"patch":[[{"diffs":[[0,"or\r\n    "],[-1,"void "],[0,"sendCapa"]],"start1":1249,"start2":1249,"length1":21,"length2":16}]],"length":6366,"saved":false}
{"ts":1352752382178,"patch":[[{"diffs":[[0,"terests,"],[1," "],[0,"uint8 *l"]],"start1":1439,"start2":1439,"length1":16,"length2":17}]],"length":6367,"saved":false}
{"contributors":[],"silentsave":true,"ts":1352858027704,"patch":[[{"diffs":[[0,"LITIES];\r\n    \r\n"],[1,"    \r\n    \r\n"],[0,"    // Set up st"]],"start1":4464,"start2":4464,"length1":32,"length2":44}]],"length":6379,"saved":false}
{"ts":1352858033383,"patch":[[{"diffs":[[0,"TIES];\r\n    "],[1,"message m"],[0,"\r\n    \r\n    "]],"start1":4466,"start2":4466,"length1":24,"length2":33}]],"length":6388,"saved":false}
{"ts":1352858038858,"patch":[[{"diffs":[[0,"essage m"],[-1,"\r\n    "],[1,"yMessage;\r\n    \r\n    myMessage"],[0,"\r\n    \r\n"]],"start1":4479,"start2":4479,"length1":22,"length2":46}]],"length":6412,"saved":false}
{"ts":1352858040280,"patch":[[{"diffs":[[0,"  \r\n    "],[-1,"myMessage"],[0,"\r\n    \r\n"]],"start1":4500,"start2":4500,"length1":25,"length2":16}]],"length":6403,"saved":false}
{"ts":1352858047291,"patch":[[{"diffs":[[0,"BILITIES];\r\n"],[1,"    \r\n"],[0,"    message "]],"start1":4462,"start2":4462,"length1":24,"length2":30}]],"length":6409,"saved":false}
{"ts":1352858048865,"patch":[[{"diffs":[[0,"TIES];\r\n    "],[1,"uint8 "],[0,"\r\n    messag"]],"start1":4466,"start2":4466,"length1":24,"length2":30}]],"length":6415,"saved":false}
{"ts":1352858050929,"patch":[[{"diffs":[[0,"  uint8 "],[1,"rfData"],[0,"\r\n    me"]],"start1":4476,"start2":4476,"length1":16,"length2":22}]],"length":6421,"saved":false}
{"ts":1352858052596,"patch":[[{"diffs":[[0,"8 rfData"],[1," "],[0,"\r\n    me"]],"start1":4482,"start2":4482,"length1":16,"length2":17}]],"length":6422,"saved":false}
{"ts":1352858053908,"patch":[[{"diffs":[[0,"8 rfData"],[-1," "],[1,"["],[0,"\r\n    me"]],"start1":4482,"start2":4482,"length1":17,"length2":17}]],"length":6422,"saved":false}
{"ts":1352858055001,"patch":[[{"diffs":[[0," rfData["],[1,"getM"],[0,"\r\n    me"]],"start1":4483,"start2":4483,"length1":16,"length2":20}]],"length":6426,"saved":false}
{"ts":1352858056376,"patch":[[{"diffs":[[0,"ata[getM"],[1,"essageLe"],[0,"\r\n    me"]],"start1":4487,"start2":4487,"length1":16,"length2":24}]],"length":6434,"saved":false}
{"ts":1352858058110,"patch":[[{"diffs":[[0,"essageLe"],[1,"ngth()]"],[0,"\r\n    me"]],"start1":4495,"start2":4495,"length1":16,"length2":23}]],"length":6441,"saved":false}
{"ts":1352858058912,"patch":[[{"diffs":[[0,"ength()]"],[1,";"],[0,"\r\n    me"]],"start1":4502,"start2":4502,"length1":16,"length2":17}]],"length":6442,"saved":false}
{"ts":1352858066426,"patch":[[{"diffs":[[0,"];\r\n"],[-1,"    uint8 rfData[getMessageLength()];\r\n    message myMessage;\r\n"],[0,"    "]],"start1":4470,"start2":4470,"length1":71,"length2":8}]],"length":6379,"saved":false}
{"ts":1352858067752,"patch":[[{"diffs":[[0,"\r\n    \r\n"],[-1,"    \r\n    \r\n"],[0,"    // S"]],"start1":4472,"start2":4472,"length1":28,"length2":16}]],"length":6367,"saved":false}
