{"ts":1352707207034,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"\r\n#include <whan_protocol.h>\r\n\r\nstatic uint8 myCapabilities[] = {UNIT_TYPE_DEGREES_C_ENVIRONMENT,\r\n    UNIT_TYPE_PRESSURE, UNIT_TYPE_LUMENS};\r\nstatic uint8 myInterests[] = {UNIT_TYPE_OCCUPANTS};\r\n    \r\nstatic uint8 myInterests[0]; // No interests\r\n\r\n\r\n// Function pointers\r\nvoid serviceSubscribeRequest(uint16 networkAddress, uint32 macHi, uint32 macLow,\r\n    message *myMessage);\r\nvoid serviceSubscribeInstruction(uint16 networkAddress, uint32 macHi, \r\n    uint32 macLow, message *myMessage);\r\nvoid serviceNotificationRequest(uint16 networkAddress, message *myMessage);\r\nint32 getLastMeasurement(uint8 type);\r\nvoid sleepForTenMinutes(void);\r\nvoid init(void);\r\nint32 measureTemp(void);\r\nint32 measurePressure(void);\r\nint32 measureLumens(void);\r\n\r\n// Main loop\r\nvoid main(void)\r\n{\r\n    // Initialize variables for measurements\r\n    int32 temperature, pressure, light;\r\n    // Initialize notification struct\r\n    notification myNotification;\r\n    \r\n    // Point struct to lists in memory\r\n    int32 notifData[3];\r\n    int8 notifTypes[3];\r\n    myNotification.data = notifData;\r\n    myNotification.types = notifTypes;\r\n    // Specify number of notifications\r\n    myNotification.numNotifications = 3;\r\n    \r\n    // Initialize some stuff\r\n    init();\r\n    \r\n    // Send measurement capabilities to coordinator\r\n    void sendCapabilitiesNotification(MY_NUM_CAPABILITIES, myCapabilities);\r\n    \r\n    \r\n    // Send measurement interests to cooridnator\r\n    sendInterestsNotification(MY_NUM_INTERESTS, myInterests,uint8 *locales);\r\n    \r\n    while(1)\r\n    {\r\n        // Measure temperature\r\n        temperature = measureTemp();\r\n        // Put measured temp data into struct\r\n        myNotification.data[0] = temperature;\r\n        myNotification.types[0] = UNIT_TYPE_DEGREES_C_ENVIRONMENT;\r\n        \r\n        // Measure pressure\r\n        pressure = measurePressure();\r\n        // Put measured pressure data into struct\r\n        myNotificaiton.data[1] = pressure;\r\n        myNotification.types[1] = UNIT_TYPE_PRESSURE;\r\n        \r\n        // Measure light\r\n        light = measureLight();\r\n        // Put measured light data into struct\r\n        myNotification.data[2] = light;\r\n        myNotification.types[2] = UNIT_TYPE_LUMENS;\r\n        \r\n        // Send notification data to address book entries that are interested\r\n        notifyInterestedNodes(myNotification);\r\n        \r\n        // Wait for a while\r\n        sleepForTenMinutes();\r\n        \r\n    }\r\n    \r\n}\r\n\r\n// Should be called when a Subscribe Request has been received\r\nvoid serviceSubscribeRequest(uint16 networkAddress, uint32 macHi, uint32 macLow,\r\n    message *myMessage)\r\n{\r\n    // Add node to address book (if there is space)\r\n    if (numFreeAddressEntries() > 0)\r\n    {\r\n        addNodeToAddressBook(networkAddress, macHi, macLow, \r\n            *myMessage.sourceLocale, *myMessage.data[0],\r\n            (uint8*)(*myMessage.data + 1), 0, myCapabilities);\r\n            \r\n    }\r\n    \r\n}\r\n\r\n// Should be called when a Subscribe Instruction has been received\r\nvoid serviceSubscribeInstruction(uint16 networkAddress, uint32 macHi, \r\n    uint32 macLow, message *myMessage)\r\n{\r\n    // Get data needed to add node to address book\r\n    uint16 targetNetworkAddress = *myMessage.data[1] + \r\n        (*myMessage.data[0] << 8);\r\n    uint32 targetMacHi = *myMessage.data[5] + \r\n        (*myMessage.data[4] << 8) + \r\n        (*myMessage.data[3] << 16) + \r\n        (*myMessage.data[2] << 24);\r\n    uint32 targetMacLow = *myMessage.data[9] + \r\n        (*myMessage.data[8] << 8) + \r\n        (*myMessage.data[7] << 16) + \r\n        (*myMessage.data[6] << 24);\r\n    uint8 targetLocale = *myMessage.data[10];\r\n    uint8 targetNumCapabilities = *myMessage.data[11];\r\n    uint8 *targetCapabilities = (uint8*)(*myMessage.data + 12);\r\n    \r\n    // Add node to address book (if there is space)\r\n    if (numFreeAddressEntries() > 0)\r\n    {\r\n        addNodeToAddressBook(targetNetworkAddress, targetMacHi, targetMacLow,\r\n            targetLocale, 0, myInterests, targetNumCapabilities,\r\n            targetCapabilities);\r\n    }\r\n    \r\n    // Request subscription from target node\r\n    sendSubscribeRequest(targetNetworkAddress, MY_NUM_INTERESTS, myInterests);\r\n    \r\n}\r\n\r\n// Should be called when a Notification Request command has been received\r\nvoid serviceNotificationRequest(uint16 networkAddress, message *myMessage)\r\n{\r\n    // Declare variables to be used in this context\r\n    uint8 i = 0, j = 0;\r\n    notificaiton N;\r\n    uint32 nData[MY_NUM_CAPABILITIES];\r\n    uint8 nTypes[MY_NUM_CAPABILITIES];\r\n    \r\n    // Set up struct pointers to lists on stack\r\n    N.numNotifications = 0;\r\n    N.data = nData;\r\n    N.types = nTypes;\r\n    \r\n    // For all types that are in both the notification request and this node's\r\n    // list of capabilities, append their latest measurements to the\r\n    // notification\r\n    for (i = 0; i < MY_NUM_CAPABILITIES; i++)\r\n    {\r\n        for (j = 0; j < *myMessage.data[0]; j++)\r\n        {\r\n            if (myCapabilities[i] == *myMessage.data[j+1])\r\n            {\r\n                // If one of this node's capabilities are found in the\r\n                // notification request, add to the notification\r\n                N.data[N.numNotifications] = getLastMeasurement(*myMessage.data[j+1]);\r\n                N.types[N.numNotifications] = *myMessage.data[j+1];\r\n                N.numNotifications += 1;\r\n                \r\n            }\r\n        }\r\n    }\r\n    \r\n    // If there are notifications to be sent, send them\r\n    if (N.numNotifications > 0)\r\n    {\r\n        sendNotification(uint16 networkAddress, N);\r\n    }\r\n    \r\n}\r\n\r\n// Retrieves the last measurement of a given type\r\nint32 getLastMeasurement(uint8 type)\r\n{\r\n    int32 result = 0;\r\n    \r\n    if (type == UNIT_TYPE_DEGREES_C_ENVIRONMENT)\r\n    {\r\n        result = measureTemp();\r\n    }\r\n    else if (type == UNIT_TYPE_PRESSURE)\r\n    {\r\n        result = measurePressure();\r\n    } \r\n    else if (type == UNIT_TYPE_LUMENS)\r\n    {\r\n        result = measureLumens();\r\n    }\r\n    \r\n    return result;\r\n    \r\n}\r\n\r\n// Sleep for ten minutes\r\nvoid sleepForTenMinutes(void)\r\n{\r\n    return; // It's a very fast ten minutes.\r\n}\r\n\r\nvoid init(void)\r\n{\r\n    return; // Not much to initialize, I suppose...\r\n}\r\n\r\nint32 measureTemp(void)\r\n{\r\n    return 0x00000001;\r\n}\r\n\r\nint32 measurePressure(void)\r\n{\r\n    return 0x00000002;\r\n}\r\n\r\nint32 measureLumens(void)\r\n{\r\n    return 0x00000003;\r\n}\r\n"]],"start1":0,"start2":0,"length1":0,"length2":6389}]],"length":6389}
{"contributors":[],"silentsave":false,"ts":1352707206961,"patch":[[{"diffs":[[1,"\r\n#include <whan_protocol.h>\r\n\r\nstatic uint8 myCapabilities[] = {UNIT_TYPE_DEGREES_C_ENVIRONMENT,\r\n    UNIT_TYPE_PRESSURE, UNIT_TYPE_LUMENS};\r\nstatic uint8 myInterests[] = {UNIT_TYPE_OCCUPANTS};\r\n    \r\nstatic uint8 myInterests[0]; // No interests\r\n\r\n\r\n// Function pointers\r\nvoid serviceSubscribeRequest(uint16 networkAddress, uint32 macHi, uint32 macLow,\r\n    message *myMessage);\r\nvoid serviceSubscribeInstruction(uint16 networkAddress, uint32 macHi, \r\n    uint32 macLow, message *myMessage);\r\nvoid serviceNotificationRequest(uint16 networkAddress, message *myMessage);\r\nint32 getLastMeasurement(uint8 type);\r\nvoid sleepForTenMinutes(void);\r\nvoid init(void);\r\nint32 measureTemp(void);\r\nint32 measurePressure(void);\r\nint32 measureLumens(void);\r\n\r\n// Main loop\r\nvoid main(void)\r\n{\r\n    // Initialize variables for measurements\r\n    int32 temperature, pressure, light;\r\n    // Initialize notification struct\r\n    notification myNotification;\r\n    \r\n    // Point struct to lists in memory\r\n    int32 notifData[3];\r\n    int8 notifTypes[3];\r\n    myNotification.data = notifData;\r\n    myNotification.types = notifTypes;\r\n    // Specify number of notifications\r\n    myNotification.numNotifications = 3;\r\n    \r\n    // Initialize some stuff\r\n    init();\r\n    \r\n    // Send measurement capabilities to coordinator\r\n    void sendCapabilitiesNotification(MY_NUM_CAPABILITIES, myCapabilities);\r\n    \r\n    \r\n    // Send measurement interests to cooridnator\r\n    sendInterestsNotification(MY_NUM_INTERESTS, myInterests,uint8 *locales);\r\n    \r\n    while(1)\r\n    {\r\n        // Measure temperature\r\n        temperature = measureTemp();\r\n        // Put measured temp data into struct\r\n        myNotification.data[0] = temperature;\r\n        myNotification.types[0] = UNIT_TYPE_DEGREES_C_ENVIRONMENT;\r\n        \r\n        // Measure pressure\r\n        pressure = measurePressure();\r\n        // Put measured pressure data into struct\r\n        myNotificaiton.data[1] = pressure;\r\n        myNotification.types[1] = UNIT_TYPE_PRESSURE;\r\n        \r\n        // Measure light\r\n        light = measureLight();\r\n        // Put measured light data into struct\r\n        myNotification.data[2] = light;\r\n        myNotification.types[2] = UNIT_TYPE_LUMENS;\r\n        \r\n        // Send notification data to address book entries that are interested\r\n        notifyInterestedNodes(myNotification);\r\n        \r\n        // Wait for a while\r\n        sleepForTenMinutes();\r\n        \r\n    }\r\n    \r\n}\r\n\r\n// Should be called when a Subscribe Request has been received\r\nvoid serviceSubscribeRequest(uint16 networkAddress, uint32 macHi, uint32 macLow,\r\n    message *myMessage)\r\n{\r\n    // Add node to address book (if there is space)\r\n    if (numFreeAddressEntries() > 0)\r\n    {\r\n        addNodeToAddressBook(networkAddress, macHi, macLow, \r\n            *myMessage.sourceLocale, *myMessage.data[0],\r\n            (uint8*)(*myMessage.data + 1), 0, myCapabilities);\r\n            \r\n    }\r\n    \r\n}\r\n\r\n// Should be called when a Subscribe Instruction has been received\r\nvoid serviceSubscribeInstruction(uint16 networkAddress, uint32 macHi, \r\n    uint32 macLow, message *myMessage)\r\n{\r\n    // Get data needed to add node to address book\r\n    uint16 targetNetworkAddress = *myMessage.data[1] + \r\n        (*myMessage.data[0] << 8);\r\n    uint32 targetMacHi = *myMessage.data[5] + \r\n        (*myMessage.data[4] << 8) + \r\n        (*myMessage.data[3] << 16) + \r\n        (*myMessage.data[2] << 24);\r\n    uint32 targetMacLow = *myMessage.data[9] + \r\n        (*myMessage.data[8] << 8) + \r\n        (*myMessage.data[7] << 16) + \r\n        (*myMessage.data[6] << 24);\r\n    uint8 targetLocale = *myMessage.data[10];\r\n    uint8 targetNumCapabilities = *myMessage.data[11];\r\n    uint8 *targetCapabilities = (uint8*)(*myMessage.data + 12);\r\n    \r\n    // Add node to address book (if there is space)\r\n    if (numFreeAddressEntries() > 0)\r\n    {\r\n        addNodeToAddressBook(targetNetworkAddress, targetMacHi, targetMacLow,\r\n            targetLocale, 0, myInterests, targetNumCapabilities,\r\n            targetCapabilities);\r\n    }\r\n    \r\n    // Request subscription from target node\r\n    sendSubscribeRequest(targetNetworkAddress, MY_NUM_INTERESTS, myInterests);\r\n    \r\n}\r\n\r\n// Should be called when a Notification Request command has been received\r\nvoid serviceNotificationRequest(uint16 networkAddress, message *myMessage)\r\n{\r\n    // Declare variables to be used in this context\r\n    uint8 i = 0, j = 0;\r\n    notificaiton N;\r\n    uint32 nData[MY_NUM_CAPABILITIES];\r\n    uint8 nTypes[MY_NUM_CAPABILITIES];\r\n    \r\n    // Set up struct pointers to lists on stack\r\n    N.numNotifications = 0;\r\n    N.data = nData;\r\n    N.types = nTypes;\r\n    \r\n    // For all types that are in both the notification request and this node's\r\n    // list of capabilities, append their latest measurements to the\r\n    // notification\r\n    for (i = 0; i < MY_NUM_CAPABILITIES; i++)\r\n    {\r\n        for (j = 0; j < *myMessage.data[0]; j++)\r\n        {\r\n            if (myCapabilities[i] == *myMessage.data[j+1])\r\n            {\r\n                // If one of this node's capabilities are found in the\r\n                // notification request, add to the notification\r\n                N.data[N.numNotifications] = getLastMeasurement(*myMessage.data[j+1]);\r\n                N.types[N.numNotifications] = *myMessage.data[j+1];\r\n                N.numNotifications += 1;\r\n                \r\n            }\r\n        }\r\n    }\r\n    \r\n    // If there are notifications to be sent, send them\r\n    if (N.numNotifications > 0)\r\n    {\r\n        sendNotification(uint16 networkAddress, N);\r\n    }\r\n    \r\n}\r\n\r\n// Retrieves the last measurement of a given type\r\nint32 getLastMeasurement(uint8 type)\r\n{\r\n    int32 result = 0;\r\n    \r\n    if (type == UNIT_TYPE_DEGREES_C_ENVIRONMENT)\r\n    {\r\n        result = measureTemp();\r\n    }\r\n    else if (type == UNIT_TYPE_PRESSURE)\r\n    {\r\n        result = measurePressure();\r\n    } \r\n    else if (type == UNIT_TYPE_LUMENS)\r\n    {\r\n        result = measureLumens();\r\n    }\r\n    \r\n    return result;\r\n    \r\n}\r\n\r\n// Sleep for ten minutes\r\nvoid sleepForTenMinutes(void)\r\n{\r\n    return; // It's a very fast ten minutes.\r\n}\r\n\r\nvoid init(void)\r\n{\r\n    return; // Not much to initialize, I suppose...\r\n}\r\n\r\nint32 measureTemp(void)\r\n{\r\n    return 0x00000001;\r\n}\r\n\r\nint32 measurePressure(void)\r\n{\r\n    return 0x00000002;\r\n}\r\n\r\nint32 measureLumens(void)\r\n{\r\n    return 0x00000003;\r\n}\r\n"]],"start1":0,"start2":0,"length1":0,"length2":6389}]],"length":6389,"saved":false}
{"contributors":[],"silentsave":true,"ts":1352707422939,"patch":[[{"diffs":[[0,"  \r\n"],[-1,"static uint8 myInterests[0]; // No interests\r\n\r\n\r\n// Function pointers\r\nvoid serviceSubscribeRequest(uint16 networkAddress, uint32 macHi, uint32 macLow,\r\n    message *myMessage);\r\nvoid serviceSubscribeInstruction(uint16 networkAddress, uint32 macHi, \r\n    uint32 macLow, message *myMessage);\r\nvoid serviceNotificationRequest(uint16 networkAddress, message *myMessage);\r\nint32 getLastMeasurement(uint8 type);\r\nvoid sleepForTenMinutes(void);\r\nvoid init(void);\r\nint32 measureTemp(void);\r\nint32 measurePressure(void);\r\nint32 measureLumens(void);\r\n\r\n// Main loop\r\nvoid main(void)\r\n{\r\n    // Initialize variables for measurements\r\n    int32 temperature, pressure, light;\r\n    // Initialize notification struct\r\n    notification myNotification;\r\n    \r\n    // Point struct to lists in memory\r\n    int32 notifData[3];\r\n    int8 notifTypes[3];\r\n    myNotification.data = notifData;\r\n    myNotification.types = notifTypes;\r\n    // Specify number of notifications\r\n    myNotification.numNotifications = 3;\r\n    \r\n    // Initialize some stuff\r\n    init();\r\n    \r\n    // Send measurement capabilities to coordinator\r\n    void sendCapabilitiesNotification(MY_NUM_CAPABILITIES, myCapabilities);\r\n    \r\n    \r\n    // Send measurement interests to cooridnator\r\n    sendInterestsNotification(MY_NUM_INTERESTS, myInterests,uint8 *locales);\r\n    \r\n    while(1)\r\n    {\r\n        // Measure temperature\r\n        temperature = measureTemp();\r\n        // Put measured temp data into struct\r\n        myNotification.data[0] = temperature;\r\n        myNotification.types[0] = UNIT_TYPE_DEGREES_C_ENVIRONMENT;\r\n        \r\n        // Measure pressure\r\n        pressure = measurePressure();\r\n        // Put measured pressure data into struct\r\n        myNotificaiton.data[1] = pressure;\r\n        myNotification.types[1] = UNIT_TYPE_PRESSURE;\r\n        \r\n        // Measure light\r\n        light = measureLight();\r\n        // Put measured light data into struct\r\n        myNotification.data[2] = light;\r\n        myNotification.types[2] = UNIT_TYPE_LUMENS;\r\n        \r\n        // Send notification data to address book entries that are interested\r\n        notifyInterestedNodes(myNotification);\r\n        \r\n        // Wait for a while\r\n        sleepForTenMinutes();\r\n        \r\n    }\r\n    \r\n}\r\n\r\n// Should be called when a Subscribe Request has been received\r\nvoid serviceSubscribeRequest(uint16 networkAddress, uint32 macHi, uint32 macLow,\r\n    message *myMessage)\r\n{\r\n    // Add node to address book (if there is space)\r\n    if (numFreeAddressEntries() > 0)\r\n    {\r\n        addNodeToAddressBook(networkAddress, macHi, macLow, \r\n            *myMessage.sourceLocale, *myMessage.data[0],\r\n            (uint8*)(*myMessage.data + 1), 0, myCapabilities);\r\n            \r\n    }\r\n    \r\n}\r\n\r\n// Should be called when a Subscribe Instruction has been received\r\nvoid serviceSubscribeInstruction(uint16 networkAddress, uint32 macHi, \r\n    uint32 macLow, message *myMessage)\r\n{\r\n    // Get data needed to add node to address book\r\n    uint16 targetNetworkAddress = *myMessage.data[1] + \r\n        (*myMessage.data[0] << 8);\r\n    uint32 targetMacHi = *myMessage.data[5] + \r\n        (*myMessage.data[4] << 8) + \r\n        (*myMessage.data[3] << 16) + \r\n        (*myMessage.data[2] << 24);\r\n    uint32 targetMacLow = *myMessage.data[9] + \r\n        (*myMessage.data[8] << 8) + \r\n        (*myMessage.data[7] << 16) + \r\n        (*myMessage.data[6] << 24);\r\n    uint8 targetLocale = *myMessage.data[10];\r\n    uint8 targetNumCapabilities = *myMessage.data[11];\r\n    uint8 *targetCapabilities = (uint8*)(*myMessage.data + 12);\r\n    \r\n    // Add node to address book (if there is space)\r\n    if (numFreeAddressEntries() > 0)\r\n    {\r\n        addNodeToAddressBook(targetNetworkAddress, targetMacHi, targetMacLow,\r\n            targetLocale, 0, myInterests, targetNumCapabilities,\r\n            targetCapabilities);\r\n    }\r\n    \r\n    // Request subscription from target node\r\n    sendSubscribeRequest(targetNetworkAddress, MY_NUM_INTERESTS, myInterests);\r\n    \r\n}\r\n\r\n// Should be called when a Notification Request command has been received\r\nvoid serviceNotificationRequest(uint16 networkAddress, message *myMessage)\r\n{\r\n    // Declare variables to be used in this context\r\n    uint8 i = 0, j = 0;\r\n    notificaiton N;\r\n    uint32 nData[MY_NUM_CAPABILITIES];\r\n    uint8 nTypes[MY_NUM_CAPABILITIES];\r\n    \r\n    // Set up struct pointers to lists on stack\r\n    N.numNotifications = 0;\r\n    N.data = nData;\r\n    N.types = nTypes;\r\n    \r\n    // For all types that are in both the notification request and this node's\r\n    // list of capabilities, append their latest measurements to the\r\n    // notification\r\n    for (i = 0; i < MY_NUM_CAPABILITIES; i++)\r\n    {\r\n        for (j = 0; j < *myMessage.data[0]; j++)\r\n        {\r\n            if (myCapabilities[i] == *myMessage.data[j+1])\r\n            {\r\n                // If one of this node's capabilities are found in the\r\n                // notification request, add to the notification\r\n                N.data[N.numNotifications] = getLastMeasurement(*myMessage.data[j+1]);\r\n                N.types[N.numNotifications] = *myMessage.data[j+1];\r\n                N.numNotifications += 1;\r\n                \r\n            }\r\n        }\r\n    }\r\n    \r\n    // If there are notifications to be sent, send them\r\n    if (N.numNotifications > 0)\r\n    {\r\n        sendNotification(uint16 networkAddress, N);\r\n    }\r\n    \r\n}\r\n\r\n// Retrieves the last measurement of a given type\r\nint32 getLastMeasurement(uint8 type)\r\n{\r\n    int32 result = 0;\r\n    \r\n    if (type == UNIT_TYPE_DEGREES_C_ENVIRONMENT)\r\n    {\r\n        result = measureTemp();\r\n    }\r\n    else if (type == UNIT_TYPE_PRESSURE)\r\n    {\r\n        result = measurePressure();\r\n    } \r\n    else if (type == UNIT_TYPE_LUMENS)\r\n    {\r\n        result = measureLumens();\r\n    }\r\n    \r\n    return result;\r\n    \r\n}\r\n\r\n// Sleep for ten minutes\r\nvoid sleepForTenMinutes(void)\r\n{\r\n    return; // It's a very fast ten minutes.\r\n}\r\n\r\nvoid init(void)\r\n{\r\n    return; // Not much to initialize, I suppose...\r\n}\r\n\r\nint32 measureTemp(void)\r\n{\r\n    return 0x00000001;\r\n}\r\n\r\nint32 measurePressure(void)\r\n{\r\n    return 0x00000002;\r\n}\r\n\r\nint32 measureLumens(void)\r\n{\r\n    return 0x00000003;\r\n}\r\n\r\n#include <whan_protocol.h>\r\n\r\nstatic uint8 myCapabilities[] = {UNIT_TYPE_DEGREES_C_ENVIRONMENT,\r\n    UNIT_TYPE_PRESSURE, UNIT_TYPE_LUMENS};\r\nstatic uint8 myInterests[] = {UNIT_TYPE_OCCUPANTS};\r\n    \r\nstatic uint8 myInterests[0]; // No interests\r\n"],[0,"\r\n\r\n"]],"start1":198,"start2":198,"length1":6443,"length2":8}]],"length":6343,"saved":false}
{"ts":1352707424332,"patch":[[{"diffs":[[0,"ANTS};\r\n"],[-1,"    \r\n"],[0,"\r\n\r\n// F"]],"start1":188,"start2":188,"length1":22,"length2":16}]],"length":6337,"saved":false}
{"contributors":[],"silentsave":true,"ts":1352749710800,"patch":[[{"diffs":[[0," }\r\n        "],[-1,"}"],[1,"    \r\n        }\r\n        "],[0,"\r\n    }\r\n   "]],"start1":5339,"start2":5339,"length1":25,"length2":49}]],"length":6361,"saved":false}
{"ts":1352749790399,"patch":[[{"diffs":[[0,"dress, N);\r\n"],[1,"        \r\n"],[0,"    }\r\n    \r"]],"start1":5529,"start2":5529,"length1":24,"length2":34}]],"length":6371,"saved":false}
{"ts":1352751966415,"patch":[[{"diffs":[[0,"or\r\n    "],[-1,"void "],[0,"sendCapa"]],"start1":1249,"start2":1249,"length1":21,"length2":16}]],"length":6366,"saved":false}
{"ts":1352752382178,"patch":[[{"diffs":[[0,"terests,"],[1," "],[0,"uint8 *l"]],"start1":1439,"start2":1439,"length1":16,"length2":17}]],"length":6367,"saved":false}
{"contributors":[],"silentsave":true,"ts":1352858027704,"patch":[[{"diffs":[[0,"LITIES];\r\n    \r\n"],[1,"    \r\n    \r\n"],[0,"    // Set up st"]],"start1":4464,"start2":4464,"length1":32,"length2":44}]],"length":6379,"saved":false}
{"ts":1352858033383,"patch":[[{"diffs":[[0,"TIES];\r\n    "],[1,"message m"],[0,"\r\n    \r\n    "]],"start1":4466,"start2":4466,"length1":24,"length2":33}]],"length":6388,"saved":false}
{"ts":1352858038858,"patch":[[{"diffs":[[0,"essage m"],[-1,"\r\n    "],[1,"yMessage;\r\n    \r\n    myMessage"],[0,"\r\n    \r\n"]],"start1":4479,"start2":4479,"length1":22,"length2":46}]],"length":6412,"saved":false}
{"ts":1352858040280,"patch":[[{"diffs":[[0,"  \r\n    "],[-1,"myMessage"],[0,"\r\n    \r\n"]],"start1":4500,"start2":4500,"length1":25,"length2":16}]],"length":6403,"saved":false}
{"ts":1352858047291,"patch":[[{"diffs":[[0,"BILITIES];\r\n"],[1,"    \r\n"],[0,"    message "]],"start1":4462,"start2":4462,"length1":24,"length2":30}]],"length":6409,"saved":false}
{"ts":1352858048865,"patch":[[{"diffs":[[0,"TIES];\r\n    "],[1,"uint8 "],[0,"\r\n    messag"]],"start1":4466,"start2":4466,"length1":24,"length2":30}]],"length":6415,"saved":false}
{"ts":1352858050929,"patch":[[{"diffs":[[0,"  uint8 "],[1,"rfData"],[0,"\r\n    me"]],"start1":4476,"start2":4476,"length1":16,"length2":22}]],"length":6421,"saved":false}
{"ts":1352858052596,"patch":[[{"diffs":[[0,"8 rfData"],[1," "],[0,"\r\n    me"]],"start1":4482,"start2":4482,"length1":16,"length2":17}]],"length":6422,"saved":false}
{"ts":1352858053908,"patch":[[{"diffs":[[0,"8 rfData"],[-1," "],[1,"["],[0,"\r\n    me"]],"start1":4482,"start2":4482,"length1":17,"length2":17}]],"length":6422,"saved":false}
{"ts":1352858055001,"patch":[[{"diffs":[[0," rfData["],[1,"getM"],[0,"\r\n    me"]],"start1":4483,"start2":4483,"length1":16,"length2":20}]],"length":6426,"saved":false}
{"ts":1352858056376,"patch":[[{"diffs":[[0,"ata[getM"],[1,"essageLe"],[0,"\r\n    me"]],"start1":4487,"start2":4487,"length1":16,"length2":24}]],"length":6434,"saved":false}
{"ts":1352858058110,"patch":[[{"diffs":[[0,"essageLe"],[1,"ngth()]"],[0,"\r\n    me"]],"start1":4495,"start2":4495,"length1":16,"length2":23}]],"length":6441,"saved":false}
{"ts":1352858058912,"patch":[[{"diffs":[[0,"ength()]"],[1,";"],[0,"\r\n    me"]],"start1":4502,"start2":4502,"length1":16,"length2":17}]],"length":6442,"saved":false}
{"ts":1352858066426,"patch":[[{"diffs":[[0,"];\r\n"],[-1,"    uint8 rfData[getMessageLength()];\r\n    message myMessage;\r\n"],[0,"    "]],"start1":4470,"start2":4470,"length1":71,"length2":8}]],"length":6379,"saved":false}
{"ts":1352858067752,"patch":[[{"diffs":[[0,"\r\n    \r\n"],[-1,"    \r\n    \r\n"],[0,"    // S"]],"start1":4472,"start2":4472,"length1":28,"length2":16}]],"length":6367,"saved":false}
{"ts":1353093321660,"patch":[[{"diffs":[[0,"include "],[-1,"<"],[1,"\""],[0,"whan_pro"]],"start1":3,"start2":3,"length1":17,"length2":17}]],"length":6367,"saved":false}
{"ts":1353093322961,"patch":[[{"diffs":[[0,"otocol.h"],[-1,">"],[1,"\""],[0,"\r\n\r\nstat"]],"start1":19,"start2":19,"length1":17,"length2":17}]],"length":6367,"saved":false}
{"contributors":[],"silentsave":false,"ts":1353377920036,"patch":[[{"diffs":[[-1,"\r\n#include \"whan_protocol.h\"\r\n\r\nstatic uint8 myCapabilities[] = {UNIT_TYPE_DEGREES_C_ENVIRONMENT,\r\n    UNIT_TYPE_PRESSURE, UNIT_TYPE_LUMENS};\r\nstatic uint8 myInterests[] = {UNIT_TYPE_OCCUPANTS};\r\n\r\n\r\n// Function pointers\r\nvoid serviceSubscribeRequest(uint16 networkAddress, uint32 macHi, uint32 macLow,\r\n    "],[1,"/* ========================================\r\n *\r\n * Copyright YOUR COMPANY, THE YEAR\r\n * All Rights Reserved\r\n * UNPUBLISHED, LICENSED SOFTWARE.\r\n *\r\n * CONFIDENTIAL AND PROPRIETARY INFORMATION\r\n * WHICH IS THE PROPERTY OF your company.\r\n *\r\n * ========================================\r\n*/\r\n\r\n#include <device.h>\r\n#include \"whan_protocol.h\"\r\n\r\nvoid initComponents(void);\r\n\r\nvolatile uint8 messageReceived = 0x00;\r\n\r\nvoid serviceUserCommand(message myMessage);\r\nvoid serviceNotification(message myMessage);\r\nvoid serviceNotificationRequest("],[0,"message "],[-1,"*"],[0,"myMe"]],"start1":0,"start2":0,"length1":321,"length2":551},{"diffs":[[0,"ribe"],[-1,"Instruction(uint16 networkAddress, uint32 macHi, \r\n    uint32 macLow, "],[1,"Request(message myMessage);\r\nvoid serviceResponse("],[0,"message "],[-1,"*"],[0,"myMe"]],"start1":577,"start2":577,"length1":87,"length2":66},{"diffs":[[0,");\r\nvoid service"],[1,"Interest"],[0,"NotificationRequ"]],"start1":648,"start2":648,"length1":32,"length2":40},{"diffs":[[0,"tion"],[-1,"Request(uint16 networkAddress, "],[1,"(message myMessage);\r\nvoid serviceCapabilityNotification("],[0,"message "],[-1,"*"],[0,"myMe"]],"start1":680,"start2":680,"length1":48,"length2":73},{"diffs":[[0,");\r\n"],[-1,"int32 getLastMeasurement(uint8 type);\r\nvoid sleepForTenMinutes(void);\r\nvoid init(void);\r\nint32 measureTemp(void);\r\nint32 measurePressure(void);\r\nint32 measureLumens(void);\r\n\r\n// Main loop"],[1,"void serviceSubscribeInstruction(message myMessage);\r\nvoid serviceSubscribeInstruction(message myMessage);\r\nvoid serviceSafetyAlarm(message myMessage);\r\nvoid serviceRawData(message myMessage);\r\n\r\n"],[0,"\r\nvo"]],"start1":758,"start2":758,"length1":195,"length2":204},{"diffs":[[0,"ain("],[-1,"void"],[0,")\r\n{\r\n"],[-1,"    // Initialize variables for measurements\r\n    int32 temperature, pressure, light;\r\n    // Initialize notification struct\r\n    notification myN"],[1,"//    uint32 macHi = 0, macLow = 0;\r\n//\tuint16 networkAddress = 0;\r\n\t\r\n\tuint8 messageData[MAX_SINGLE_MESSAGE_LENGTH];\r\n\tmessage myMessage;\r\n\tmyMessage.data = messageData;\r\n\t\r\n/*\tuint8 interests[] = {0x01, 0x02, 0x03};\r\n\tuint8 capabilities[] = {0x05};\r\n\r\n\tn"],[0,"otif"]],"start1":966,"start2":966,"length1":164,"length2":270},{"diffs":[[0,"tion"],[1," N"],[0,";\r\n"],[-1,"    \r\n    // Point struct to lists in memory\r\n    int32 notifData[3];\r\n    int8 notifTypes[3];\r\n    my"],[1,"\t\r\n\t\r\n\tuint8 numNotifs = 2;\r\n\tuint8 notifTypes[] = {0x01, 0x03};\r\n\tint32 notifData[] = {0xa1a2a3a4, 0xb1b2b3b4};\r\n\r\n\tN.num"],[0,"Noti"]],"start1":1239,"start2":1239,"length1":113,"length2":135},{"diffs":[[0,"tion"],[-1,".data"],[1,"s"],[0," = n"],[1,"umN"],[0,"otif"],[-1,"Data;\r\n    myNotification.types = notifTypes;\r\n    // Specify number of notifications\r\n    myNotification.numNotifications = 3;\r\n    \r\n    // Initialize some stuff\r\n    init();\r\n    \r\n    // Send measurement capabilities to coordinator\r\n    sendCapabilitiesNotification(MY_NUM_CAPABILITIES, myCapabilities);\r\n    \r\n    \r\n    // Send measurement interests to cooridnator\r\n    sendInterestsNotification(MY_NUM_INTERESTS, myInterests, uint8 *locales);\r\n    \r\n    while(1)\r\n    {\r\n        // Measure temperature\r\n        temperature = measureTemp();\r\n        // Pu"],[1,"s;\r\n\tN.types = notifTypes;\r\n\tN.data = notifData;*/\r\n\r\n    initComponents();\r\n\t\r\n/*\r\n\tnotifyInterestedNodes(N);\r\n\t\r\n\taddNodeToAddressBook(0x1234, 0x98765432, 0x12345678, 0xaa, 0x03, interests, 0x01, capabilities);\r\n\r\n\tnotifyInterestedNodes(N);\r\n\t\r\n\tsendRawData(0x1234, 0x03, interests);*/\r\n\t\r\n\t\r\n    CyGlobalIntEnable; /* Uncomment this line to enable global interrupts. */\r\n    for(;;)\r\n    {\r\n        /* Place your application code here. */\r\n\t\tif (messageReceived != 0)\r\n\t\t{\r\n\t\t\t// Ge"],[0,"t me"],[-1,"asured temp data into struct\r\n        myNotification.data[0] = temperature;\r\n        myNotification.types[0] = UNIT_TYPE_DEGREES_C_ENVIRONMENT;\r\n        \r\n        // Measure pressure\r\n        pressure = measurePressure();\r\n        // Put measured pressure data into struct\r\n        myNotificaiton.data[1] = pressure;\r\n        myNotification.types[1] = UNIT_TYPE_PRESSURE;\r\n        \r\n        // Measure light\r\n        light = measureLight();\r\n        // Put measured light data into struct\r\n        myNotification.data[2] = light;\r\n        myNotification.types[2] = UNIT_TYPE_LUMENS;\r\n        \r\n        // Send notification data to address book entries that are interested\r\n        notifyInterestedNodes(myNotification);\r\n        \r\n        // Wait for a while\r\n        sleepForTenMinutes();\r\n        \r\n    }\r\n    "],[1,"ssage contents\r\n\t\t\tgetMessageStruct(myMessage);\r\n\t\t\t\r\n\t\t\tswitch (myMessage.type) {\r\n\t\t\tcase MESSAGE_TYPE_USER_COMMAND:\r\n\t\t\t\tserviceUserCommand(myMessage);\r\n\t\t\t\tbreak;\r\n\t\t\t\t\r\n\t\t\tcase MESSAGE_TYPE_NOTIFICATION:\r\n\t\t\t\tserviceNotification(myMessage);\r\n\t\t\t\tbreak;\r\n\t\t\t\t\r\n\t\t\tcase MESSAGE_TYPE_NOTIFICATION_REQUEST:\r\n\t\t\t\tserviceNotificationRequest(myMessage);\r\n\t\t\t\tbreak;\r\n\t\t\t\t\r\n\t\t\tcase MESSAGE_TYPE_SUBSCRIBE_REQUEST:\r\n\t\t\t\tserviceSubscribeRequest(myMessage);\r\n\t\t\t\tbreak;\r\n\t\t\t\t\r\n\t\t\tcase MESSAGE_TYPE_RESPONSE:\r\n\t\t\t\tserviceResponse(myMessage);\r\n\t\t\t\tbreak;\r\n\t\t\t\t\r\n\t\t\tcase MESSAGE_TYPE_INTEREST_NOTIFICATION:\r\n\t\t\t\tserviceInterestNotification(myMessage);\r\n\t\t\t\tbreak;\r\n\t\t\t\t\r\n\t\t\tcase MESSAGE_TYPE_CAPABILITY_NOTIFICATION:\r\n\t\t\t\tserviceCapabilityNotification(myMessage);\r\n\t\t\t\tbreak;\r\n\t\t\t\t\r\n\t\t\tcase MESSAGE_TYPE_SUBSCRIBE_INSTRUCTION:\r\n\t\t\t\tserviceSubscribeInstruction(myMessage);\r\n\t\t\t\tbreak;\r\n\t\t\t\t\r\n\t\t\tcase MESSAGE_TYPE_SAFETY_ALARM:\r\n\t\t\t\tserviceSafetyAlarm(myMessage);\r\n\t\t\t\tbreak;\r\n\t\t\t\t\r\n\t\t\tcase MESSAGE_TYPE_RAW_DATA:\r\n\t\t\t\tserviceRawData(myMessage);\r\n\t\t\t\tbreak;\r\n\t\t\t\t\r\n\t\t\tdefault:\r\n\t\t\t\t// Command type not recognized\r\n\t\t\t\tbreak;\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t\r\n\t\t\tmessageReceived = 0;\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n    }\r\n\t\r\n}\r\n\r\nvoid initComponents(void)\r\n{\r\n\tZigbee_UART_1_Start();\r\n\t\r\n\tRxInterrupt_Start();\r\n\t\r\n}\r\n\r\n// Should be called when a user command is received\r\nvoid serviceUserCommand(message myMessage)\r\n{\r\n\r\n}\r\n\r\n// Should be called when a notification is received\r\nvoid serviceNotification(message myMessage)\r\n{\r\n\r\n}\r\n\r\n// Should be called when a notification request is received\r\nvoid serviceNotificationRequest(message myMessage)\r\n{\r\n"],[0,"\r\n}\r"]],"start1":1378,"start2":1378,"length1":1397,"length2":2120},{"diffs":[[0,"e called when a "],[-1,"S"],[1,"s"],[0,"ubscribe Request"]],"start1":3512,"start2":3512,"length1":33,"length2":33},{"diffs":[[0,"ibe "],[-1,"R"],[1,"r"],[0,"equest "],[-1,"has been"],[1,"is"],[0," rec"]],"start1":3534,"start2":3534,"length1":24,"length2":18},{"diffs":[[0,"est("],[-1,"uint16 networkAddress, uint32 macHi, uint32 macLow,\r\n    "],[1,"message myMessage)\r\n{\r\n\r\n}\r\n\r\n// Should be called when a response is received\r\nvoid serviceResponse("],[0,"message "],[-1,"*"],[0,"myMe"]],"start1":3584,"start2":3584,"length1":74,"length2":116},{"diffs":[[0,"\n{\r\n"],[-1,"    // Add node to address book (if there is space)\r\n    if (numFreeAddressEntries() > 0)\r\n    {\r\n        addNodeToAddressBook(networkAddress, macHi, macLow, \r\n            *myMessage.sourceLocale, *myMessage.data[0],\r\n            (uint8*)(*myMessage.data + 1), 0, myCapabilities);\r\n            \r\n    }\r\n    "],[1,"\r\n}\r\n\r\n// Should be called when an interest notification is received\r\nvoid serviceInterestNotification(message myMessage)\r\n{\r\n\r\n}\r\n\r\n// Should be called when a capability notification is received\r\nvoid serviceCapabilityNotification(message myMessage)\r\n{\r\n"],[0,"\r\n}\r"]],"start1":3707,"start2":3707,"length1":315,"length2":263},{"diffs":[[0,"ion("],[-1,"uint16 networkAddress, uint32 macHi, \r\n    uint32 macLow, "],[0,"message "],[-1,"*"],[0,"myMe"]],"start1":4070,"start2":4070,"length1":75,"length2":16},{"diffs":[[0,"rkAddress = "],[-1,"*"],[0,"myMessage.da"]],"start1":4171,"start2":4171,"length1":25,"length2":24},{"diffs":[[0,"1] + \r\n        ("],[-1,"*"],[0,"myMessage.data[0"]],"start1":4198,"start2":4198,"length1":33,"length2":32},{"diffs":[[0,"MacHi = "],[-1,"*"],[0,"myMessag"]],"start1":4257,"start2":4257,"length1":17,"length2":16},{"diffs":[[0,"5] + \r\n        ("],[-1,"*"],[0,"myMessage.data[4"]],"start1":4280,"start2":4280,"length1":33,"length2":32},{"diffs":[[0,"8) + \r\n        ("],[-1,"*"],[0,"myMessage.data[3"]],"start1":4317,"start2":4317,"length1":33,"length2":32},{"diffs":[[0,"6) + \r\n        ("],[-1,"*"],[0,"myMessage.data[2"]],"start1":4355,"start2":4355,"length1":33,"length2":32},{"diffs":[[0,"acLow = "],[-1,"*"],[0,"myMessag"]],"start1":4416,"start2":4416,"length1":17,"length2":16},{"diffs":[[0,"9] + \r\n        ("],[-1,"*"],[0,"myMessage.data[8"]],"start1":4439,"start2":4439,"length1":33,"length2":32},{"diffs":[[0,"8) + \r\n        ("],[-1,"*"],[0,"myMessage.data[7"]],"start1":4476,"start2":4476,"length1":33,"length2":32},{"diffs":[[0,"       ("],[-1,"*"],[0,"myMessag"]],"start1":4522,"start2":4522,"length1":17,"length2":16},{"diffs":[[0,"ocale = "],[-1,"*"],[0,"myMessag"]],"start1":4574,"start2":4574,"length1":17,"length2":16},{"diffs":[[0,"ities = "],[-1,"*"],[0,"myMessag"]],"start1":4629,"start2":4629,"length1":17,"length2":16},{"diffs":[[0,"uint8*)("],[-1,"*"],[0,"myMessag"]],"start1":4691,"start2":4691,"length1":17,"length2":16},{"diffs":[[0,"ale, 0, "],[-1,"m"],[1,"getM"],[0,"yInteres"]],"start1":4926,"start2":4926,"length1":17,"length2":20},{"diffs":[[0,"nterests"],[1,"Ptr()"],[0,", target"]],"start1":4940,"start2":4940,"length1":16,"length2":21},{"diffs":[[0,"ERESTS, "],[-1,"m"],[1,"\r\n\t\tgetM"],[0,"yInteres"]],"start1":5129,"start2":5129,"length1":17,"length2":24},{"diffs":[[0,"nterests"],[1,"Ptr()"],[0,");\r\n    "]],"start1":5147,"start2":5147,"length1":16,"length2":21},{"diffs":[[0,"n a "],[-1,"Notification Request command has been received\r\nvoid serviceNotificationRequest(uint16 networkAddress, "],[1,"safety alarm is received\r\nvoid serviceSafetyAlarm("],[0,"message "],[-1,"*"],[0,"myMe"]],"start1":5198,"start2":5198,"length1":120,"length2":66},{"diffs":[[0,"\n{\r\n"],[-1,"    // Declare variables to be used in this context\r\n    uint8 i = 0, j = 0;\r\n    notificaiton N;\r\n    uint32 nData[MY_NUM_CAPABILITIES];\r\n    uint8 nTypes[MY_NUM_CAPABILITIES];\r\n    \r\n    // Set up struct pointers to lists on stack\r\n    N.numNotifications = 0;\r\n    N.data = nData;\r\n    N.types = nTypes;\r\n    \r\n    // For all types that are in both the notification request and this node's\r\n    // list of capabilities, append their latest measurements to the\r\n    // notification\r\n    for (i = 0; i < MY_NUM_CAPABILITIES; i++)\r\n    {\r\n        for (j = 0; j < *myMessage.data[0]; j++)\r\n        {\r\n            if (myCapabilities[i] == *myMessage.data[j+1])\r\n            {\r\n                // If one of this node's capabilities are found in the\r\n                // notification request, add to the notification\r\n                N.data[N.numNotifications] = getLastMeasurement(*myMessage.data[j+1]);\r\n                N.types[N.numNotifications] = *myMessage.data[j+1];\r\n                N.numNotifications += 1;\r\n                \r\n            }\r\n            \r\n        }\r\n        \r\n    }\r\n    \r\n    // If there are notifications to be sent, send them\r\n    if (N.numNotifications > 0)\r\n    {\r\n        sendNotification(uint16 networkAddress, N);\r\n        \r\n    }\r\n    \r\n}\r\n\r\n// Retrieves the last measurement of a given type\r\nint32 getLastMeasurement(uint8 type)\r\n{\r\n    int32 result = 0;\r\n    \r\n    if (type == UNIT_TYPE_DEGREES_C_ENVIRONMENT)\r\n    {\r\n        result = measureTemp();\r\n    }\r\n    else if (type == UNIT_TYPE_PRESSURE)\r\n    {\r\n        result = measurePressure();\r\n    } \r\n    else if (type == UNIT_TYPE_LUMENS)\r\n    {\r\n        result = measureLumens();\r\n    }\r\n    \r\n    return result;\r\n    \r\n}\r\n\r\n// Sleep for ten minutes\r\nvoid sleepForTenMinutes(void)\r\n{\r\n    return; // It's a very fast ten minutes.\r\n}\r\n\r\nvoid init(void)\r\n{\r\n    return; // Not much to initialize, I suppose...\r\n}\r\n\r\nint32 measureTemp(void)\r\n{\r\n    return 0x00000001;\r\n}\r\n\r\nint32 measurePressure(void)\r\n{\r\n    return 0x00000002;\r\n}\r\n\r\nint32 measureLumens(void)\r\n{\r\n    return 0x00000003;\r\n}"],[1,"\r\n}\r\n\r\n// Should be called when a raw data message is received\r\nvoid serviceRawData(message myMessage)\r\n{\r\n\r\n}\r\n\r\n/* [] END OF FILE */"],[0,"\r\n"]],"start1":5271,"start2":5271,"length1":2076,"length2":140}]],"length":5411,"saved":false}
{"ts":1353390753766,"patch":[[{"diffs":[[0,"h\"\r\n"],[-1,"\r\nvoid initComponents(void);\r\n\r\nvolatile uint8 messageReceived = 0x00"],[1,"#include \"light_timer.h\"\r\n#include \"light_control.h\"\r\n\r\n// Define device operating modes\r\n#define OPERATING_MODE_HOLD 0x00\r\n#define OPERATING_MODE_AUTO 0x01\r\n#define OPERATING_MODE_USER_CONTROL 0x02\r\n\r\nvoid initComponents(void)"],[0,";\r\n\r"]],"start1":338,"start2":338,"length1":77,"length2":235},{"diffs":[[0,");\r\n"],[-1,"\r\n\r\nvoid main()\r\n{\r\n//    uint32 macHi = 0, macLow"],[1,"void actOnNotification(int32 notifData, uint8 notifType);\r\n\r\n\r\nvolatile uint8 messageReceived = 0x00;\r\nstatic uint8 operatingMode = 0x00;\r\nextern uint8 myInterests[];\r\n\r\n// Current device state:\r\n//    * Is it on or off?\r\n//\t* What operating mode is it in?\r\n//\t* What dimming level is it at? (on = 0x7fffffff, off"],[0," = 0"],[-1,";"],[1,")"],[0,"\r\n//\t"],[-1,"uint16 networkAddress = 0;"],[1,"* Average watt usage since last power notification?\r\n#define STATE_INDEX_POWERED 0\r\n#define STATE_INDEX_OPERATING_MODE 1\r\n#define STATE_INDEX_DIMMING_LEVEL 2\r\n#define STATE_INDEX_AVERAGE_POWER 3\r\n#define STATE_INDEX_ENVIRONMENT_LUMENS 4\r\n#define NUM_STATE_VARIABLES 5\r\n// Types for each device state variable\r\nstatic uint8 stateType[] = {UNIT_TYPE_POWERED, UNIT_TYPE_OPERATING_MODE,\r\n\tUNIT_TYPE_DIMMING_LEVEL, UNIT_TYPE_WATTS, UNIT_TYPE_LUMENS};\r\n// Data for each device state variable\r\nstatic int32 stateCurrent[] = {0, 0, 0, 0, 0};\r\n// Goals for each device state variable\r\nstatic int32 stateGoal[] = {0, 0, 0, 0, 0};\r\n\r\n// Define light delta threshold (what is \"close enough\"?)\r\n#define LIGHT_DELTA_THRESHOLD 50 // Lumens\r\n\r\n\r\n\r\nvoid main()\r\n{"],[0,"\r\n\t\r"]],"start1":1110,"start2":1110,"length1":94,"length2":1077},{"diffs":[[0,"eStruct("],[-1,""],[0,""],[1,"&"],[0,"myMessag"]],"start1":3052,"start2":3052,"length1":16,"length2":17},{"diffs":[[0,"id)\r\n{\r\n"],[1,"\t// Note!  Device state should be initialized before normal operation begins!\r\n\t\r\n"],[0,"\tZigbee_"]],"start1":4238,"start2":4238,"length1":16,"length2":98},{"diffs":[[0,"rt();\r\n\t"],[1,"initLight();"],[0,"\r\n\tRxInt"]],"start1":4346,"start2":4346,"length1":16,"length2":28},{"diffs":[[0,"\n{\r\n"],[-1,"\r\n}\r\n\r\n// Should be called when a notification is received\r\nvoid serviceNotification(message myMessage)\r\n{\r\n"],[1,"\tuint8 i = 0;\r\n\tuserCommand myUserCommand;\r\n\t\r\n\t// Populate user command from message\r\n\tgetUserCommand(&myUserCommand, myMessage);\r\n\t\r\n\tif (myUserCommand.command == USER_COMMAND_CHANGE_VALUE)\r\n\t{\r\n\t\t// Change requested goal if possible\r\n\t\tif (myUserCommand.type == UNIT_TYPE_LOCALE)\r\n\t\t{\r\n\t\t\tsetMyLocale((uint8)myUserCommand.data);\r\n\t\t}\r\n\t\telse \r\n\t\t{\r\n\t\t\tfor (i = 0; i < NUM_STATE_VARIABLES; i++)\r\n\t\t\t{\r\n\t\t\t\tif (stateType[i] == myUserCommand.type)\r\n\t\t\t\t{\r\n\t\t\t\t\tstateGoal[i] = myUserCommand.data;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t}\r\n\telse if (myUserCommand.command == USER_COMMAND_PROMPT_ABILITIES)\r\n\t{\r\n\t\t// Send coordinator capabilities notification\r\n\t\t// TODO: should an interest notificaiton be sent as well?\r\n\t\t// sendMyInterestsNotification();\r\n\t\t// CyDelay(100);\r\n\t\tsendMyCapabilitiesNotification();\r\n\t\t\r\n\t}\r\n\t\r\n}\r\n\r\n// Should be called when a notification is received\r\nvoid serviceNotification(message myMessage)\r\n{\r\n\t#ifdef ACTOR\r\n\t\t// Create notificaiton in memory\r\n\t\tnotification myNotification;\r\n\t\tint32 notifData[MY_NUM_INTERESTS];\r\n\t\tuint8 notifTypes[MY_NUM_INTERESTS];\r\n\t\tuint8 i = 0, k = 0;\r\n\t\t\r\n\t\t// Map notification struct contents\r\n\t\tmyNotification.numNotifications = MY_NUM_INTERESTS;\r\n\t\tmyNotification.data = notifData;\r\n\t\tmyNotification.types = notifTypes;\r\n\t\t\r\n\t\t// Retreive notification data from message\r\n\t\tgetNotification(&myNotification, myMessage);\r\n\t\t\r\n\t\tfor (i = 0; i < myNotification.numNotifications; i++)\r\n\t\t{\r\n\t\t\tfor (k = 0; k < MY_NUM_INTERESTS; k++)\r\n\t\t\t{\r\n\t\t\t\tif (myNotification.types[i] == myInterests[k])\r\n\t\t\t\t{\r\n\t\t\t\t\tactOnNotification(myNotification.data[i], \r\n\t\t\t\t\t\tmyNotification.types[i]);\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t#endif"],[0,"\r\n}\r"]],"start1":4495,"start2":4495,"length1":116,"length2":1709},{"diffs":[[0," myMessage)\r\n{\r\n"],[-1,""],[0,""],[1,"\t#ifdef SENSOR\r\n\t\t\r\n\t\t// Insert application specific code here\r\n\t\t\r\n\t#endif"],[0,"\r\n}\r\n\r\n// Should"]],"start1":6307,"start2":6307,"length1":32,"length2":107},{"diffs":[[0," myMessage)\r\n{\r\n"],[-1,""],[0,""],[1,"\t#ifdef SENSOR\r\n\t\t\r\n\t\t// Insert application specific code here\r\n\t\t\r\n\t#endif"],[0,"\r\n}\r\n\r\n// Should"]],"start1":6499,"start2":6499,"length1":32,"length2":107},{"diffs":[[0," myMessage)\r\n{\r\n"],[-1,""],[0,""],[1,"\t// Insert application specific code here"],[0,"\r\n}\r\n\r\n// Should"]],"start1":6674,"start2":6674,"length1":32,"length2":73},{"diffs":[[0," myMessage)\r\n{\r\n"],[-1,""],[0,""],[1,"\t#ifdef COORDINATOR\r\n\t\t\r\n\t\t// Insert application specific code here\r\n\t\r\n\t#endif"],[0,"\r\n}\r\n\r\n// Should"]],"start1":6841,"start2":6841,"length1":32,"length2":111},{"diffs":[[0," myMessage)\r\n{\r\n"],[-1,""],[0,""],[1,"\t#ifdef COORDINATOR\r\n\t\t\r\n\t\t// Insert application specific code here\r\n\t\t\r\n\t#endif"],[0,"\r\n}\r\n\r\n// Should"]],"start1":7049,"start2":7049,"length1":32,"length2":112},{"diffs":[[0,"ge)\r\n{\r\n"],[1,"\t#ifdef ACTOR\r\n\t"],[0,"    // G"]],"start1":7268,"start2":7268,"length1":16,"length2":32},{"diffs":[[0,"s book\r\n"],[1,"\t"],[0,"    uint"]],"start1":7336,"start2":7336,"length1":16,"length2":17},{"diffs":[[0,"data[1] + \r\n"],[1,"\t"],[0,"        (myM"]],"start1":7389,"start2":7389,"length1":24,"length2":25},{"diffs":[[0,"[0] << 8);\r\n"],[1,"\t"],[0,"    uint32 t"]],"start1":7425,"start2":7425,"length1":24,"length2":25},{"diffs":[[0,"data[5] + \r\n"],[1,"\t"],[0,"        (myM"]],"start1":7473,"start2":7473,"length1":24,"length2":25},{"diffs":[[0,"ta[4] << 8) + \r\n"],[1,"\t"],[0,"        (myMessa"]],"start1":7507,"start2":7507,"length1":32,"length2":33},{"diffs":[[0,"a[3] << 16) + \r\n"],[1,"\t"],[0,"        (myMessa"]],"start1":7546,"start2":7546,"length1":32,"length2":33},{"diffs":[[0,"ata[2] << 24);\r\n"],[1,"\t"],[0,"    uint32 targe"]],"start1":7583,"start2":7583,"length1":32,"length2":33},{"diffs":[[0,"data[9] + \r\n"],[1,"\t"],[0,"        (myM"]],"start1":7636,"start2":7636,"length1":24,"length2":25},{"diffs":[[0,"] << 8) + \r\n"],[1,"\t"],[0,"        (myM"]],"start1":7674,"start2":7674,"length1":24,"length2":25},{"diffs":[[0,"16) + \r\n"],[1,"\t"],[0,"        "]],"start1":7717,"start2":7717,"length1":16,"length2":17},{"diffs":[[0,"6] << 24);\r\n"],[1,"\t"],[0,"    uint8 ta"]],"start1":7750,"start2":7750,"length1":24,"length2":25},{"diffs":[[0,".data[10];\r\n"],[1,"\t"],[0,"    uint8 ta"]],"start1":7797,"start2":7797,"length1":24,"length2":25},{"diffs":[[0,"a[11];\r\n"],[1,"\t"],[0,"    uint"]],"start1":7857,"start2":7857,"length1":16,"length2":17},{"diffs":[[0,"+ 12);\r\n"],[1,"\t"],[0,"    \r\n"],[1,"\t"],[0,"    // A"]],"start1":7922,"start2":7922,"length1":22,"length2":24},{"diffs":[[0,"space)\r\n"],[1,"\t"],[0,"    if ("]],"start1":7983,"start2":7983,"length1":16,"length2":17},{"diffs":[[0,") > 0)\r\n"],[1,"\t"],[0,"    {\r\n"],[1,"\t"],[0,"        "]],"start1":8022,"start2":8022,"length1":23,"length2":25},{"diffs":[[0,"tMacHi, "],[1,"\r\n\t\t\t\t"],[0,"targetMa"]],"start1":8095,"start2":8095,"length1":16,"length2":22},{"diffs":[[0,"tMacLow,"],[-1,"\r\n           "],[0," targetL"]],"start1":8114,"start2":8114,"length1":29,"length2":16},{"diffs":[[0,"sPtr(), "],[1,"\r\n\t\t\t\t"],[0,"targetNu"]],"start1":8153,"start2":8153,"length1":16,"length2":22},{"diffs":[[0,"ies,"],[-1,"\r\n           "],[0," tar"]],"start1":8185,"start2":8185,"length1":21,"length2":8},{"diffs":[[0,");\r\n"],[1,"\t"],[0,"    }\r\n"],[1,"\t"],[0,"    \r\n"],[1,"\t"],[0,"    "]],"start1":8208,"start2":8208,"length1":21,"length2":24},{"diffs":[[0,"t node\r\n"],[1,"\t"],[0,"    send"]],"start1":8266,"start2":8266,"length1":16,"length2":17},{"diffs":[[0,"TS, \r\n\t\t"],[1,"\t"],[0,"getMyInt"]],"start1":8336,"start2":8336,"length1":16,"length2":17},{"diffs":[[0,"\r\n    \r\n"],[1,"\t#endif\r\n"],[0,"}\r\n\r\n// "]],"start1":8366,"start2":8366,"length1":16,"length2":25},{"diffs":[[0," myMessage)\r\n{\r\n"],[-1,""],[0,""],[1,"\t// Insert application specific code here"],[0,"\r\n}\r\n\r\n// Should"]],"start1":8472,"start2":8472,"length1":32,"length2":73},{"diffs":[[0,"ge)\r\n{\r\n"],[1,"\t// Insert application specific code here\r\n}\r\n\r\n// Act on notification based on type, handles singular notifications\r\nvoid actOnNotification(int32 notifData, uint8 notifType)\r\n{\r\n\tif (notifType == UNIT_TYPE_LUMENS)\r\n\t{\r\n\t\tstateCurrent[STATE_INDEX_ENVIRONMENT_LUMENS] = notifData;\r\n\t\r\n\t}\r\n\telse if (notifType == UNIT_TYPE_OCCUPANTS)\r\n\t{\r\n\t\tif (operatingMode == OPERATING_MODE_AUTO)\r\n\t\t{\r\n\t\t\tturnOn();\r\n\t\t\t\r\n\t\t\tstartTurnOffTimer();\r\n\t\t\tresetTurnOffTimer();\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t}\r\n\t"],[0,"\r\n}\r\n\r\n/"]],"start1":8628,"start2":8628,"length1":16,"length2":491}]],"length":9140,"saved":false}
{"ts":1353392002125,"patch":[[{"diffs":[[0,"ubscribeRequest("],[-1,""],[0,""],[1,"uint16 srcNetworkAddress, uint32 srcMacLow, \r\n    uint32 srcMacHi, "],[0,"message myMessag"]],"start1":731,"start2":731,"length1":32,"length2":99},{"diffs":[[0,"ate:\r\n//"],[-1,"    "],[1,"\t"],[0,"* Is it "]],"start1":1371,"start2":1371,"length1":20,"length2":17},{"diffs":[[0,"eData;\r\n"],[1,"\tuint32 srcMacHi = 0, srcMacLow = 0;\r\n\tuint16 srcNetworkAddress = 0;\r\n"],[0,"\t\r\n/*\tui"]],"start1":2345,"start2":2345,"length1":16,"length2":86},{"diffs":[[0,"Struct(&"],[-1,""],[0,""],[1,"srcNetworkAddress, &srcMacLow, &srcMacHi, \r\n\t\t\t\t&"],[0,"myMessag"]],"start1":3187,"start2":3187,"length1":16,"length2":65},{"diffs":[[0,"ubscribeRequest("],[-1,""],[0,""],[1,"srcNetworkAddress, srcMacLow, srcMacHi,\r\n\t\t\t\t\t"],[0,"myMessage);\r\n\t\t\t"]],"start1":3632,"start2":3632,"length1":32,"length2":78},{"diffs":[[0,"UM_INTERESTS];\r\n"],[1,"\t\tuint8 *interests = getMyInterestsPtr();\r\n"],[0,"\t\tuint8 i = 0, k"]],"start1":5817,"start2":5817,"length1":32,"length2":75},{"diffs":[[0,"s[i] == "],[-1,"myI"],[1,"i"],[0,"nterests"]],"start1":6311,"start2":6311,"length1":19,"length2":17},{"diffs":[[0,"\r\n\t\t"],[-1,"\r\n\t\t// Insert application specific code here\r\n\t\t\r\n\t#endif\r\n}\r\n\r\n// Should be called when a subscribe request is received\r\nvoid serviceSubscribeRequest(message myMessage)\r\n{\r\n\t#ifdef SENSOR\r\n\t\t\r\n\t\t// Insert application specific code here"],[1,"// Create notification request struct\r\n\t\tnotificationRequest myNotificationRequest;\r\n\t\tuint8 *capabilities = getMyCapabilitiesPtr();\r\n\t\tuint8 i = 0, k = 0;\r\n\t\t\r\n\t\t// Populate struct from message buffer\r\n\t\tgetNotificationRequest(&myNotificationRequest, myMessage);\r\n\t\t\r\n\t\t\r\n\t\tfor (i = 0; i < myNotificationRequest.numTypes; i++)\r\n\t\t{\r\n\t\t\tfor (k = 0; k < MY_NUM_CAPABILITIES; k++)\r\n\t\t\t{\r\n\t\t\t\tif (myNotificationRequest.types[i] == capabilities[k])\r\n\t\t\t\t{\r\n\t\t\t\t\t\r\n\t\t\t\t\t// Insert application specific code here\r\n\t\t\t\t\t// Either give latest data or measure new data and send\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t#endif\r\n}\r\n\r\n// Should be called when a subscribe request is received\r\nvoid serviceSubscribeRequest(uint16 srcNetworkAddress, uint32 srcMacLow, \r\n\tuint32 srcMacHi, message myMessage)\r\n{\r\n\t#ifdef SENSOR\r\n\t\t// Create subscribe request struct\r\n\t\tsubscribeRequest mySubscribeRequest;\r\n\t\t\r\n\t\t// Populate struct from message\r\n\t\tgetSubscribeRequest(&mySubscribeRequest, myMessage);\r\n\t\t\r\n\t    // Add node to address book (if there is space)\r\n\t\t// TODO: Check if the node is already in the address book (update entry)\r\n\t    if (numFreeAddressEntries() > 0)\r\n\t    {\r\n\t\t\taddNodeToAddressBook(srcNetworkAddress, srcMacHi, \r\n\t\t\t\tsrcMacLow, myMessage.sourceLocale, mySubscribeRequest.numTypes,\r\n\t\t\t\tmySubscribeRequest.types, 0, getMyCapabilitiesPtr());\r\n\t\t\t\t\r\n\t\t}"],[0,"\r\n\t\t"]],"start1":6607,"start2":6607,"length1":244,"length2":1367}]],"length":10533,"saved":false}
